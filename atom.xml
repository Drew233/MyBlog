<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle_drew</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2022-01-22T09:04:29.858Z</updated>
  <id>/</id>
  
  <author>
    <name>Uncle_drew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我回来啦~</title>
    <link href="/2022/01/22/back/"/>
    <id>/2022/01/22/back/</id>
    <published>2022-01-21T16:00:00.000Z</published>
    <updated>2022-01-22T09:04:29.858Z</updated>
    
    <content type="html"><![CDATA[<p>2020-10-19 是我上一篇文章的时间<br>2022-1-22 是这篇文章的时间</p><p>一年多的时间没有更新，一方面是不知道写什么了，一方面是懒了，还有就是，博客被我丢了<br>某暴躁大哥说我一天天就知道睡觉，还知道博客怎么写吗？</p><p>现在似乎是找回来了？</p>]]></content>
    
    <summary type="html">
    
      历经不知道多少天，我似乎又更新了？
    
    </summary>
    
      <category term="Life" scheme="/categories/Life/"/>
    
    
      <category term="Life" scheme="/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>👴眼里有了你，所以有光</title>
    <link href="/2020/10/19/wylyg/"/>
    <id>/2020/10/19/wylyg/</id>
    <published>2020-10-19T13:07:00.000Z</published>
    <updated>2020-10-20T14:57:55.748Z</updated>
    
    <content type="html"><![CDATA[<p>纪念一下</p>]]></content>
    
    <summary type="html">
    
      感谢教练的助攻，respect
    
    </summary>
    
      <category term="Life" scheme="/categories/Life/"/>
    
    
      <category term="life" scheme="/tags/life/"/>
    
      <category term="love" scheme="/tags/love/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 668 (Div. 2) D. Tree Tag</title>
    <link href="/2020/09/28/cf1404B/"/>
    <id>/2020/09/28/cf1404B/</id>
    <published>2020-09-28T01:42:17.000Z</published>
    <updated>2020-10-20T14:57:55.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-668-Div-2-D-Tree-Tag"><a href="#Codeforces-Round-668-Div-2-D-Tree-Tag" class="headerlink" title="Codeforces Round 668 (Div. 2) D. Tree Tag"></a>Codeforces Round 668 (Div. 2) D. Tree Tag</h1><div class="note link green"><p>Link: <a href="https://codeforces.com/contest/1405/problem/D" target="_blank" rel="noopener">Codeforces Round 668 (Div. 2) D. Tree Tag</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>Alice and Bob are playing a fun game of tree tag.</p><p>The game is played on a tree of n vertices numbered from 1 to n. Recall that a tree on n vertices is an undirected, connected graph with n−1 edges.</p><p>Initially, Alice is located at vertex a, and Bob at vertex b. They take turns alternately, and Alice makes the first move. In a move, Alice can jump to a vertex with distance at most da from the current vertex. And in a move, Bob can jump to a vertex with distance at most db from the current vertex. The distance between two vertices is defined as the number of edges on the unique simple path between them. In particular, either player is allowed to stay at the same vertex in a move. Note that when performing a move, a player only occupies the starting and ending vertices of their move, not the vertices between them.</p><p>If after at most <script type="math/tex">10^100</script> moves, Alice and Bob occupy the same vertex, then Alice is declared the winner. Otherwise, Bob wins.</p><p>Determine the winner if both players play optimally.</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤1e4). Description of the test cases follows.</p><p>The first line of each test case contains five integers n,a,b,da,db (2≤n≤1e5, 1≤a,b≤n, a≠b, 1≤da,db≤n−1)  — the number of vertices, Alice&#39;s vertex, Bob&#39;s vertex, Alice&#39;s maximum jumping distance, and Bob&#39;s maximum jumping distance, respectively.</p><p>The following n−1 lines describe the edges of the tree. The i-th of these lines contains two integers u, v (1≤u,v≤n,u≠v), denoting an edge between vertices u and v. It is guaranteed that these edges form a tree structure.</p><p>It is guaranteed that the sum of n across all test cases does not exceed 1e5.</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>For each test case, output a single line containing the winner of the game: &quot;Alice&quot; or &quot;Bob&quot;.</p><p>input<br>4<br>4 3 2 1 2<br>1 2<br>1 3<br>1 4<br>6 6 1 2 5<br>1 2<br>6 5<br>2 3<br>3 4<br>4 5<br>9 3 9 2 5<br>1 2<br>1 6<br>1 9<br>1 3<br>9 5<br>7 9<br>4 8<br>4 3<br>11 8 11 3 3<br>1 2<br>11 9<br>4 9<br>6 5<br>2 10<br>3 2<br>5 9<br>8 3<br>7 4<br>7 10<br>output<br>Alice<br>Bob<br>Alice<br>Alice</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思就是给你一个无向连通图，给定两个人的初始位置以及每次最多可以前进的距离(只要距离小于这个都可以走)，问你第一个人(Alice)是否追得上第二个人(Bob),追得上的话输出Alice，否则输出Bob。</p><p>搜的是dp的tag的题，没想到遇到一个博弈论的问题（反正自己是一点思路都没有。大概看了下题解才知道怎么写了。</p><p>我们首先考虑必胜态，什么情况下一定追得上呢，就是以下这三种</p><ol><li>Alice每次可以移动的最大距离大于两个人的初始距离，直接冲着Bob去就追上了</li><li>Alice每次可以移动的最大距离大于图中最远的两个点之间的距离的一半，也就是说Alice先跑到图的中间，任你Bob往哪去，下次Alice可以到达任何一个点，所以肯定可以捉到Bob</li><li>Alice每次可以移动的最大距离大于Bob每次可移动的最大距离的一半，因为两个人都是最优的走法，Alice是对着Bob的方向走，Bob肯定会想着远离Alice，但是如果他走到边界，Alice会越来越近，如果此时Alice每次可以移动的最大距离大于Bob每次可移动的最大距离的一半，即使Bob抓紧时间往回跑，也一定会被Alice抓到</li></ol><p>所以我们只需要考虑这三种情况就行了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 1e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int d[4][2]={1,0,0,1,-1,0,0,-1};int n,a,b,da,db,pos,head[maxn],dis[maxn];struct node{    int to,nxt;}p[maxn&lt;&lt;1];void add(int from,int to){    p[pos].nxt=head[from];    p[pos].to=to;    head[from]=pos++;}void dfs(int now,int from){    for(int i=head[now];i!=-1;i=p[i].nxt){        if(p[i].to==from)    continue;        dis[p[i].to]=dis[now]+1;        dfs(p[i].to,now);    }}int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    int t;    cin&gt;&gt;t;    while(t--){        cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;da&gt;&gt;db;        pos=0;        for(int i=1;i&lt;=n;i++)    dis[i]=0,head[i]=-1;        for(int i=1,x,y;i&lt;n;i++){            cin&gt;&gt;x&gt;&gt;y;            add(x,y);add(y,x);        }        dfs(1,0);        int ma=0,root=1;        for(int i=1;i&lt;=n;i++){            if(dis[i]&gt;ma){                ma=dis[i];                root=i;            }        }        for(int i=1;i&lt;=n;i++)    dis[i]=0;        ma=0;        dfs(root,0);        for(int i=1;i&lt;=n;i++){            ma=max(ma,dis[i]);        }        for(int i=1;i&lt;=n;i++)    dis[i]=0;        dfs(a,0);        if(da&gt;=dis[b]||da*2&gt;=ma||da*2&gt;=db)    cout&lt;&lt;&quot;Alice\n&quot;;        else cout&lt;&lt;&quot;Bob\n&quot;;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      一道搜dp搜出来的题，但是只是有一点博弈论的感觉
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="c/c++" scheme="/tags/c-c/"/>
    
      <category term="dfs" scheme="/tags/dfs/"/>
    
      <category term="树的直径" scheme="/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="codeforces" scheme="/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>You Are the One HDU - 4283</title>
    <link href="/2020/09/19/hdu4283/"/>
    <id>/2020/09/19/hdu4283/</id>
    <published>2020-09-19T02:43:42.000Z</published>
    <updated>2020-10-20T14:57:55.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="You-Are-the-One-HDU-4283"><a href="#You-Are-the-One-HDU-4283" class="headerlink" title="You Are the One HDU - 4283"></a>You Are the One HDU - 4283</h1><div class="note link green"><p>Link: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4283" target="_blank" rel="noopener">You Are the One HDU - 4283 </a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>　　The TV shows such as You Are the One has been very popular. In order to meet the need of boys who are still single, TJUT hold the show itself. The show is hold in the Small hall, so it attract a lot of boys and girls. Now there are n boys enrolling in. At the beginning, the n boys stand in a row and go to the stage one by one. However, the director suddenly knows that very boy has a value of diaosi D, if the boy is k-th one go to the stage, the unhappiness of him will be (k-1)*D, because he has to wait for (k-1) people. Luckily, there is a dark room in the Small hall, so the director can put the boy into the dark room temporarily and let the boys behind his go to stage before him. For the dark room is very narrow, the boy who first get into dark room has to leave last. The director wants to change the order of boys by the dark room, so the summary of unhappiness will be least. Can you help him?</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>　　The first line contains a single integer T, the number of test cases.  For each case, the first line is n (0 &lt; n &lt;= 100)<br>　　The next n line are n integer D1-Dn means the value of diaosi of boys (0 &lt;= Di &lt;= 100)</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>　　For each test case, output the least summary of unhappiness .</p><p>Sample Input<br>2<br>　　<br>5<br>1<br>2<br>3<br>4<br>5</p><p>5<br>5<br>4<br>3<br>2<br>2</p><p>Sample Output<br>Case #1: 20<br>Case #2: 24</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思简单来说就是给你一个序列，序列中你可以按照本来顺序选择数，每次选一个数的花费为<script type="math/tex">(k-1)*a[i]</script>，<script type="math/tex">k</script>为选择的次数，<script type="math/tex">a[i]</script>为被选择的数的值。但是你也可以将现在按照顺序来的数放到一个栈里面，想要取出来的时候再取出来。</p><p>区间dp专题里面的题，就不往别的方向思考了（然而我还是想了贪心虽然没过233</p><p>我们令<script type="math/tex">dp[i][j]</script>表示<script type="math/tex">(i,j)</script>这个区间内的数全部挑选完时的最小花费。然后我们让这个区间内的第<script type="math/tex">i</script>个数在第<script type="math/tex">k</script>次被选择，也就是说这个区间被我们分成了三部分<script type="math/tex">[i,i],[i+1,i+k-1],[i+k,j]</script>，<script type="math/tex">[i+1,i+k-1]</script>区间内的数是第<script type="math/tex">(1,k-1)</script>次被选择的，<script type="math/tex">[i+k,j]</script>区间内的数是选了<script type="math/tex">i</script>之后被选择的，所以我们可以得到一个转移方程，</p><pre><code class="lang-c++">dp[i][j]=min(dp[i][j],dp[i+1][i+k-1]+dp[i+k][j]+(k-1)*a[i]+k*(sum[j]-sum[i+k-1]))</code></pre><p>其中</p><ul><li><script type="math/tex">dp[i+1][i+k-1],dp[i+k][j]</script>为上面分析的三个区间中两个区间的最小花费</li><li><script type="math/tex">k*a[i]</script>表示的是第<script type="math/tex">i</script>个数被取走的花费</li><li><script type="math/tex">k*(sum[j]-sum[i+k-1])</script>表示的是选择了<script type="math/tex">i</script>之后剩下的所有数在原来最小的基础上要多花费的部分。</li></ul><p>然后我们枚举<script type="math/tex">i,K,length</script>每次更新最小值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst ll maxn = 105;const ll mod = 1e9+7;const ll INF = 0x3f3f3f3f;ll d[4][2]={1,0,0,1,-1,0,0,-1};ll dp[maxn][maxn],a[maxn],sum[maxn];int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    ll t,n,cas=0;    cin&gt;&gt;t;    while(t--){        cas++;        cin&gt;&gt;n;        memset(dp,0,sizeof(dp));        memset(sum,0,sizeof(sum));        for(ll i=1;i&lt;=n;i++){            for(ll j=i+1;j&lt;=n;j++){                dp[i][j]=INF;            }        }        for(ll i=1;i&lt;=n;i++){            cin&gt;&gt;a[i];            sum[i]=sum[i-1]+a[i];        }        for(ll l=2;l&lt;=n;l++){            for(ll i=1;i+l&lt;=n+1;i++){                ll j=i+l-1;                for(ll k=1;k&lt;=j-i+1;k++){                    dp[i][j]=min(dp[i][j],dp[i+1][i+k-1]+dp[i+k][j]+(k-1)*a[i]+k*(sum[j]-sum[i+k-1]));                }            }        }        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;&lt;&lt;dp[1][n]&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      区间dp第六题，板子向的题，难点在于转移方程
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="c/c++" scheme="/tags/c-c/"/>
    
      <category term="hdu" scheme="/tags/hdu/"/>
    
      <category term="区间dp" scheme="/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 106 (Div. 2) D. Coloring Brackets</title>
    <link href="/2020/09/18/cf149d/"/>
    <id>/2020/09/18/cf149d/</id>
    <published>2020-09-18T02:50:03.000Z</published>
    <updated>2020-10-20T14:57:55.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-106-Div-2-D-Coloring-Brackets"><a href="#Codeforces-Round-106-Div-2-D-Coloring-Brackets" class="headerlink" title="Codeforces Round 106 (Div. 2) D. Coloring Brackets"></a>Codeforces Round 106 (Div. 2) D. Coloring Brackets</h1><div class="note link green"><p>Link: <a href="https://codeforces.com/problemset/problem/149/D" target="_blank" rel="noopener">Codeforces Round 106 (Div. 2) D. Coloring Brackets</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>Once Petya read a problem about a bracket sequence. He gave it much thought but didn&#39;t find a solution. Today you will face it.</p><p>You are given string s. It represents a correct bracket sequence. A correct bracket sequence is the sequence of opening (&quot;(&quot;) and closing (&quot;)&quot;) brackets, such that it is possible to obtain a correct mathematical expression from it, inserting numbers and operators between the brackets. For example, such sequences as &quot;(())()&quot; and &quot;()&quot; are correct bracket sequences and such sequences as &quot;)()&quot; and &quot;(()&quot; are not.</p><p>In a correct bracket sequence each bracket corresponds to the matching bracket (an opening bracket corresponds to the matching closing bracket and vice versa). For example, in a bracket sequence shown of the figure below, the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one.</p><p>You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled:</p><p>Each bracket is either not colored any color, or is colored red, or is colored blue.<br>For any pair of matching brackets exactly one of them is colored. In other words, for any bracket the following is true: either it or the matching bracket that corresponds to it is colored.<br>No two neighboring colored brackets have the same color.<br>Find the number of different ways to color the bracket sequence. The ways should meet the above-given conditions. Two ways of coloring are considered different if they differ in the color of at least one bracket. As the result can be quite large, print it modulo 1000000007.</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>The first line contains the single string s (2 ≤ |s| ≤ 700) which represents a correct bracket sequence.</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>Print the only number — the number of ways to color the bracket sequence that meet the above given conditions modulo 1000000007</p><p>Examples<br>input<br>(())<br>output<br>12<br>input<br>(()())<br>output<br>40<br>input<br>()<br>output<br>4</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思就是给你一个合格的括号序列，每一组括号（左括号和右括号）必须且只能选出来一个进行染色，有两种颜色可以选择，并且相邻的字符所染的颜色不能相同，如果都没有染色那是可以的。现在问你这个序列有多少种合法的染色方式。<br>比如或括号序列为<script type="math/tex">()</script>，那么就有四种染色方式，我们把两种颜色记为<script type="math/tex">0</script>,<script type="math/tex">1</script><br>这四种染色方式就是<script type="math/tex">01</script>,<script type="math/tex">10</script>,<script type="math/tex">02</script>,<script type="math/tex">20</script></p><p>既然是区间dp的专题那一定得忘dp那边想啊。看了好多题解之后才知道这道题怎么写。<br>首先我们开一个思维的数组进行dp，<script type="math/tex">dp[l][r][i][j]</script>，代表的含义就是<script type="math/tex">l</script>位置上染的色为<script type="math/tex">i</script>，<script type="math/tex">r</script>位置上染的色为<script type="math/tex">j</script></p><p><script type="math/tex">dp[l][r][i][j]</script>所代表的就是从<script type="math/tex">l</script>到<script type="math/tex">r</script>这个区间内的括号的染色方案数。<br>因为限制条件里面还有一条是说，同一组括号只能并且必须有一个进行染色，所以我们首先得记录一下每个括号与之对应的另外一个括号，用一个栈就可以解决了。<br>我们从<script type="math/tex">1-n</script>这个区间开始进行dfs，采用记忆化搜索，如果现在的区间长度为<script type="math/tex">1</script>了，它的取值就是固定的了，这就是dfs的结束条件.<br>如果区间长度大于一<br>并且当此时的区间两端是对应的括号的时候，我们需要继续向之前的区间搜索（即<script type="math/tex">l+1,r-1</script>）<br>转移方程为</p><pre><code class="lang-c++">dp[l][r][i][j]=(dp[l][r][i][j]+dp[l+1][r-1][k][p])%mod</code></pre><p>因为它可以有上一个区间的值得到现在的值，我们通过对于染色的限定条件进行判断，满足的话就更新</p><p>如果区间两端的括号不相对应，我们就把这个区间拆分为两个区间接着往前搜索（即<script type="math/tex">l,m[l]</script>,<script type="math/tex">m[l]+1,r</script>） <script type="math/tex">m[l]</script>指的是与l位上的括号对应的括号的位置</p><p>转移方程为</p><pre><code class="lang-c++">dp[l][r][i][j]=(dp[l][r][i][j]+dp[l][m[l]][i][k]*dp[m[l]+1][r][p][j]%mod)%mod</code></pre><p>这就是区间dp比较明显的一个地方，如果他不是对应的括号，那我们就在这个区间内找到与他对应的，然后因为两个区间没有任何影响，所以我们应该取乘积。</p><p>关于染色条件的限制，因为我们dp数组的后两维表示的就是颜色，我们只需要判断后两维即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst ll maxn = 1e3+10;const ll mod = 1e9+7;const ll INF = 0x3f3f3f3f;ll d[4][2]={1,0,0,1,-1,0,0,-1};ll a[maxn],m[maxn],vis[maxn][maxn],dp[maxn][maxn][3][3];void dfs(ll l,ll r){    if(vis[l][r])   return ;    vis[l][r]=1; //记忆化搜索    if(l+1==r){        dp[l][r][0][1]=dp[l][r][1][0]=1;        dp[l][r][0][2]=dp[l][r][2][0]=1;    }else if(m[l]==r){        dfs(l+1,r-1);        for(ll i=0;i&lt;3;i++){            for(ll j=0;j&lt;3;j++){                for(ll k=0;k&lt;3;k++){                    for(ll p=0;p&lt;3;p++){                        if((i==0||j==0)&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=k||(i==0||k==0))&amp;&amp;(j!=p||(j==0||p==0)))//i和j是匹配位置上的两个染色需要进行判断，i和k，j和p是两组相邻的颜色所以也需要进行判断                            dp[l][r][i][j]=(dp[l][r][i][j]+dp[l+1][r-1][k][p])%mod;                    }                }            }        }    }else{        dfs(l,m[l]);dfs(m[l]+1,r);        for(ll i=0;i&lt;3;i++){            for(ll j=0;j&lt;3;j++){                for(ll k=0;k&lt;3;k++){                    for(ll p=0;p&lt;3;p++){                        if((i==0||k==0)&amp;&amp;(i!=0||k!=0)&amp;&amp;(k!=p||(k==0&amp;&amp;p==0)))//因为i和k是两个匹配位置上染的色，所以需要进行判断，k和p是相邻的两个位置所以需要判断                            dp[l][r][i][j]=(dp[l][r][i][j]+dp[l][m[l]][i][k]*dp[m[l]+1][r][p][j]%mod)%mod;                    }                }            }        }    }}int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    string s,t=&quot; &quot;;    cin&gt;&gt;s;t+=s;    ll len=t.size()-1,pos=1;    for(int i=1;i&lt;=len;i++){        if(t[i]==&#39;(&#39;)   a[pos++]=i;        else m[a[--pos]]=i;    }    dfs(1,len);    ll ans=0;    for(int i=0;i&lt;3;i++){        for(int j=0;j&lt;3;j++){            ans=(ans+dp[1][len][i][j])%mod;        }    }//所有答案累积起来    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      区间dp专题第三题，记忆化搜索+区间dp
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="c/c++" scheme="/tags/c-c/"/>
    
      <category term="记忆化搜索" scheme="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
      <category term="codeforces" scheme="/tags/codeforces/"/>
    
      <category term="区间dp" scheme="/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>凌晨惊醒，一夜无眠</title>
    <link href="/2020/07/23/xswl/"/>
    <id>/2020/07/23/xswl/</id>
    <published>2020-07-22T16:29:22.000Z</published>
    <updated>2020-10-20T14:57:58.487Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning"><p>本文可能不适合所有人群浏览。如果您患有心脏类疾病或胆子比较小，切勿点开</p></div><p>　　开始的时候是下着大雨，不知道我是在哪个地方，雨很大，我在一栋楼的往地下室走的楼梯上蹲着，窗户和门的声音也很大，亮度很低，仅能看到窗户附近的微弱的光，听到的是雨哗啦哗啦的声音。很害怕，挣扎着醒了过来，迷迷糊糊听到了还是在下雨，而且是很大的雨，以为是真的下雨了所以做了个噩梦，慢慢的清醒之后发现，只有梦里在下雨，这是个单纯的噩梦.</p><p>　　然而今夜的噩梦才刚刚开始。</p><p>　　雨停了，骑着我的电动车去了一个地方，类似于是驾校？遇到了一个女生，记不清楚是为什么了，说想跟我一起去玩。我就支开了自己所有朋友准备去跟她玩。然后发现她不是一个人，跟她一起的有四个左右的大汉。在之前闲聊的时候就听说，在这可能会有人把你骗到一个地方进行实验Or虐待，看到这几个大汉的时候我突然反应了过来，但是人很少，朋友们也在比较远的地方，直接跑肯定是不行的。还在我想着怎么自救的时候，四个大汉已经过来把我按在了地上。我一直在反抗，用尽剩余所有的力气往朋友在的那个方向喊道：“报警救我”。我敢确信他们是听到了的，因为喊完之后他们一同看向了我，但是面无表情。周围其他的人听到了我的呼救也毫无反应。终于，我还是被带走一个小黑屋里（是一个厕所），反正只有一个窗户，窗户外面是草地。他们开始虐待我，各种虐待。过程中我还一直很配合他们，甚至还觉得自己的小聪明给自己带来了很多机会。</p><p>　　等他们虐待完之后，我的所有衣服都被脱了下来，他们把我连带着我的衣服一同从窗户扔了下去。</p><p>　　当我再次醒来的时候，是赤裸的躺在一片草地里面。身下一摸是一件上衣，但不是我的。磕磕绊绊的我找到了我的上衣和内裤，唯独裤子怎么都找不到。突然周围的情况明朗了起来，我这是在我的高中的校园里面，现在正在进行高考，紧挨着窗户的那片草地拉上了隔离带。我想我的衣服可能在那里面吧。但是我进去找了找发现并没有。</p><p>　　这个时候我妈突然出现，我开始向她哭诉自己受了多少委屈，哭诉为什么我的朋友们连帮我报警都不愿意。然后继续找我的衣服，车钥匙，眼镜。可是无论怎么找都找不到了，我妈走过来跟我说，衣裳找不到就算了，回家换新的。我说还有眼镜和车钥匙没找到呢。我妈说，眼镜换个新的直接，车钥匙就在电车上插着呢。虽然我很纳闷为什么我的车钥匙竟然回到了车上，不过还是准备跟我妈走了。</p><p>　　这时候又开始下雨，我跟我妈打着伞往校门口走。但是一同走向了厕所，这个厕所里面男女厕所的认可像是迷宫一样，我上厕所的时候听到有人反锁厕所门的声音，吓得我准备跳窗户才发现这个厕所至少在三楼，没有办法回去发现是自己太害怕了，不会有人再抓我了。后来除了厕所还跟我妈说，完了，以后对厕所都有阴影了。</p><p>　　校门口的人很多，大家都在排队，这时候我妈对我说你手上怎么了。我看到自己手脖上挂着白天在驾校跟大家一起做的柳叶环，但是胳膊上手面上长满了植物，有花还有草。而且不是粘上去了，是扎根在里面了。我妈说没事，咱们直接去医院咋都给他看好。突然右边出来一个老奶奶，指着自己手上的草说，这是正常现象，不用慌。慢慢的我看到自己手上的植物都慢慢枯萎了，也就没那么害怕了。</p><p>　　我妈骑着电车带我回家，走着走着我发现这不是我回家的路啊，我赶紧跳下车，我妈停下来问我怎么了，我说这不是咱回家的路吧。她说，咱先去串个门，我不信，我说，你也不是俺妈吧？她笑了，我赶紧往回跑，路上人很多，她跑着追上来，慢慢的她快要追上我了，我一回头却没人了。<br>　　至此，惊醒。梦中的一切都是那么的不真实，但是现在仔细回想一下，逻辑又有点点严谨。</p><p>　　以上描述的为我今晚所做的噩梦大致意思，突然做了噩梦，还是这么恐怖的那种，描述出来可能没那么可怕，回想这个梦的时候我被吓哭了。不过这也只是个梦。<br>　　冷静下来想了想，为什么会做噩梦。应该是最近这段时间赶得太紧了吧。多校训练，协会大二训练，每周的组织一次积分赛，又报考了驾照，每天都很疲惫，一定要撑过去啊。</p><p>　　我一个队友今晚脱单，祝贺！（也就亿点点酸吧）</p>]]></content>
    
    <summary type="html">
    
      胆小者切勿点开
    
    </summary>
    
      <category term="Life" scheme="/categories/Life/"/>
    
    
      <category term="life" scheme="/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Domjudge的安装与使用</title>
    <link href="/2020/07/05/domjudge/"/>
    <id>/2020/07/05/domjudge/</id>
    <published>2020-07-05T14:00:30.000Z</published>
    <updated>2020-10-20T14:57:55.774Z</updated>
    
    <content type="html"><![CDATA[<div class="note link green"><p>本文参考与：<a href="https://github.com/cn-xcpc-tools/cn-xcpc-docs" target="_blank" rel="noopener">https://github.com/cn-xcpc-tools/cn-xcpc-docs</a> <br> domjudge官网：<a href="https://www.domjudge.org/" target="_blank" rel="noopener">https://www.domjudge.org/</a></p></div><div class="note bug blue"><p>配置：<br> 1. Huawei cloud学生机 Ubuntu18.04<br> 2. domjudge v7.1.1</p></div><p>注：本篇文章的目的主要是记录自己的搭建过程（其实就是傻瓜式的跟着做的），在此同时帮助到可能能帮助到的小伙伴。并不是严格的教程向文章。</p><p>简单的使用domjudge需要安装两部分，一部分是Domserver，就是网页部分，另一部分是judgehost，即判题机。</p><h2 id="Domserver"><a href="#Domserver" class="headerlink" title="Domserver"></a>Domserver</h2><h3 id="安装依赖包和功能"><a href="#安装依赖包和功能" class="headerlink" title="安装依赖包和功能"></a>安装依赖包和功能</h3><p>远程连接到服务器后首先安装依赖包和功能,一步步执行，<br>安装时选择 <code>apache2</code></p><pre><code>sudo apt-get upgrade &amp;&amp; sudo apt-get updatesudo apt install gcc g++ make zip unzip mariadb-server \        apache2 php php-cli libapache2-mod-php php-zip \        php-gd php-curl php-mysql php-json php-xml php-intl php-mbstring \        acl bsdmainutils ntp phpmyadmin python-pygments \        libcgroup-dev linuxdoc-tools linuxdoc-tools-text \        groff texlive-latex-recommended texlive-latex-extra \        texlive-fonts-recommended texlive-lang-european composersudo apt install libcurl4-gnutls-dev libjsoncpp-dev libmagic-devsudo phpenmod json</code></pre><h3 id="编译domjudge"><a href="#编译domjudge" class="headerlink" title="编译domjudge"></a>编译domjudge</h3><pre><code>wget https://www.domjudge.org/releases/domjudge-7.1.1.tar.gz</code></pre><p>不知名原因导致下载速度感人，本地下载后通过ftp传到服务器里面，下载好之后解压配置编译安装即可。</p><pre><code>tar -zxvf domjudge-7.1.1.tar.gzcd domjudge-7.1.1./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1make domserver &amp;&amp; sudo make install-domservermake docs &amp;&amp; sudo make install-docs</code></pre><p><code>./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1</code>执行这一步时遇到权限问题，按照报错提示在后面添加指定内容成功解决。</p><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><pre><code>cd /opt/domjudge/domserversudo bin/dj_setup_database -u root install</code></pre><h3 id="配置-Web-服务器"><a href="#配置-Web-服务器" class="headerlink" title="配置 Web 服务器"></a>配置 Web 服务器</h3><pre><code>cd /opt/domjudge/domserversudo ln -s /opt/domjudge/domserver/etc/apache.conf /etc/apache2/conf-available/domjudge.confsudo a2enmod rewritesudo a2enconf domjudgesudo systemctl reload apache2sudo chown www-data:www-data -R /opt/domjudge/domserver/webapp/var/*</code></pre><p>到这一步的时候如果没有出错，那么已经可以通过服务器的公网ip（ip/domjudge）查看domjudge了。<br>默认用户名为<code>admin</code>，密码生成在<code>/opt/domjudge/domserver/etc/initial_admin_password.secret</code>中，以后可以修改</p><h3 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h3><p>编辑<code>/etc/mysql/conf.d/mysql.cnf</code>，在里面添加</p><pre><code>[mysqld]max_connections = 1000max_allowed_packet = 16MBinnodb_log_file_size = 48MB</code></pre><p>其中<code>max_allowed_packet</code>数值改成两倍于题目测试数据文件的大小，<code>innodb_log_file_size</code> 数值改成十倍于题目测试数据文件的大小。<br>若使用的是 mariadb，则 <code>/etc/mysql/mariadb.conf.d/50-server.cnf</code>中 <code>max_allowed_packet</code> 一项也需要修改。(但是我用的不是)</p><p>然后重启mysql</p><pre><code>sudo systemctl restart mysql</code></pre><h3 id="配置PHP"><a href="#配置PHP" class="headerlink" title="配置PHP"></a>配置PHP</h3><p>编辑 <code>/opt/domjudge/domserver/etc/apache.conf</code>，取消以下几行内容前的注释：(在vim中直接输入/+内容就可以查找)</p><pre><code>&lt;IfModule mod_php7.c&gt;php_value max_file_uploads      100php_value upload_max_filesize   128Mphp_value post_max_size         128Mphp_value memory_limit          512M&lt;/IfModule&gt;</code></pre><p>编辑 <code>/etc/php/7.2/apache2/php.ini</code>，搜索 <code>date.timezone</code> 关键字，取消其行前注释，并将其值设为 <code>Asia/Shanghai</code>。搜索 <code>max_execution_time</code> 关键字，将其值由30改为300，防止生成队伍密码时 PHP 执行超时。</p><p>然后重启PHP</p><pre><code>sudo systemctl restart apache2</code></pre><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>编辑 <code>/etc/apache2/apache2.conf</code>，搜索 <code>KeepAlive</code> 关键字，将其值设为 <code>Off</code>，并在其后新增一行内容：</p><pre><code>MaxClients 1000</code></pre><p>然后重启Apache</p><pre><code>sudo systemctl restart apache2</code></pre><p>到这里，Domserver就设置完成了，关于domjudge的使用下面统一再说。接下来总结一下judgehost的搭建</p><h2 id="Judgehost"><a href="#Judgehost" class="headerlink" title="Judgehost"></a>Judgehost</h2><p>本着节约资源的理念（穷），domserver和judgeserver我都用在这个服务器上</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre><code>sudo apt install make sudo debootstrap libcgroup-dev lsof \        php-cli php-curl php-json php-xml php-zip procps \        gcc g++ openjdk-8-jre-headless \        openjdk-8-jdk ghc fp-compiler \        libcurl4-gnutls-dev libjsoncpp-dev libmagic-dev</code></pre><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><pre><code>cd domjudge-7.1.1./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1make judgehost &amp;&amp; sudo make install-judgehost</code></pre><p>配置的命令跟上面安装domserver的时候一样，按照报错信息操作即可。<br>这会将 judgehost 安装在 <code>/opt/domjudge/judgehost</code> 里。<br>(<code>make install-judgehost</code>会提示找不到 <code>etc/restapi.secret</code> ，可忽略，会在下面进行配置)</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code>useradd -d /nonexistent -U -M -s /bin/false domjudge-run</code></pre><p>我只添加了一个判题机。有更多的需求的可以去本文开头提到的GitHub库中查看相关操作。</p><h3 id="配置-sudoers"><a href="#配置-sudoers" class="headerlink" title="配置 sudoers"></a>配置 sudoers</h3><p>将 <code>/opt/domjudge/judgehost/etc/sudoers-domjudge</code> 复制到 <code>/etc/sudoers.d/</code> 目录下。</p><pre><code>sudo cp /opt/domjudge/judgehost/etc/sudoers-domjudge /etc/sudoers.d/</code></pre><h3 id="修改-rest-密码"><a href="#修改-rest-密码" class="headerlink" title="修改 rest 密码"></a>修改 rest 密码</h3><p>使用 vim 等文本编辑器编辑 <code>/opt/domjudge/judgehost</code> 目录下 <code>etc/restapi.secret</code> 这个文件。文件的格式为：</p><pre><code>default http://example.edu/domjudge/api/  judgehosts  MzfJYWF5agSlUfmiGEy5mgkfqU</code></pre><p>格式为 endpoint api_url username password ，endpoint 可以保持不变，api_url 根据 judgeserver 的地址进行修改，username 和 password 要与 judgeserver 上的 <code>etc/restapi.secret</code> 保持一致。<br>(这一步我没找到judgeserver，应该就是让看的domserver吧，写成一样的就行了)</p><h3 id="构建-chroot-环境"><a href="#构建-chroot-环境" class="headerlink" title="构建 chroot 环境"></a>构建 chroot 环境</h3><p>使用 vim 等文本编辑器编辑 ~/domjudge/judgehost/bin/dj_make_chroot 脚本，将 ubuntu 镜像改为国内源。（第 172 行）</p><pre><code># Ubuntu mirror, modify to match closest mirror[ -z &quot;$DEBMIRROR&quot; ] &amp;&amp; DEBMIRROR=&quot;http://mirrors.aliyun.com/ubuntu/&quot;</code></pre><p>修改之后保存并运行此脚本(bash 运行)。这一步会从源上下载必要的软件包，所以请耐心等待。</p><h3 id="设置cgroup"><a href="#设置cgroup" class="headerlink" title="设置cgroup"></a>设置cgroup</h3><p>使用 vim 等文本编辑器编辑 <code>/etc/default/grub</code> 这个文件，对其中的这一行做如下修改：</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet cgroup_enable=memory swapaccount=1&quot;</code></pre><p>然后执行：<code>update-grub</code><br>之后重启服务器</p><h3 id="启动judgehost"><a href="#启动judgehost" class="headerlink" title="启动judgehost"></a>启动judgehost</h3><pre><code>bash /opt/domjudge/judgehost/bin/create_cgroups/opt/domjudge/judgehost/bin/judgedaemon</code></pre><p>即可启动。若提示 <code>error: Call to undefined function curl_init()</code>，则可以安装 php-curl 解决</p><p>如果没有问题，看到的会是这样的页面<br><a href="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1593959944188.png" data-fancybox="images" data-caption="1593959944188.png" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1593959944188.png" class="img-shadow img-margin"></center></a><br>大概意思就是，判题机已启动，队列中没有提交</p><p>到这里judgehost就安装好了</p><p>如果想要断开连接并且还可以正常使用判题机，这样来</p><pre><code>bash /opt/domjudge/judgehost/bin/create_cgroupsnohup /opt/domjudge/judgehost/bin/judgedaemon &amp;</code></pre><p>退出连接的时候记得用<code>exit</code>，不要直接关闭</p><p>到这里，domjudge就可以正常投入使用了。</p><h2 id="Domjudge的使用"><a href="#Domjudge的使用" class="headerlink" title="Domjudge的使用"></a>Domjudge的使用</h2><p>一切都还在摸索</p><p>Loading~~~</p>]]></content>
    
    <summary type="html">
    
      为了暑期集训的时候能有我们自己的OJ出题打积分赛，我终于再次尝试起了domjudge。
    
    </summary>
    
      <category term="Tutorial" scheme="/categories/Tutorial/"/>
    
    
      <category term="domjudge" scheme="/tags/domjudge/"/>
    
      <category term="training" scheme="/tags/training/"/>
    
      <category term="Ubuntu" scheme="/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>J - Factorial Products UCF Local Programming Contest 2014</title>
    <link href="/2020/06/01/UCF2014/"/>
    <id>/2020/06/01/UCF2014/</id>
    <published>2020-06-01T01:55:46.000Z</published>
    <updated>2020-10-20T14:57:58.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Factorial-Products"><a href="#Factorial-Products" class="headerlink" title="Factorial Products"></a>Factorial Products</h1><div class="note link green"><p>Link: <a href="https://www.jisuanke.com/contest/10147/559071" target="_blank" rel="noopener">https://www.jisuanke.com/contest/10147/559071</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>Factorial is just a game of multiplications. Formally, it can be defined as a recurrence relation:</p><p>Fact (0) = 1 </p><p>Fact (n) = n * Fact(n-1), for all integers n &gt; 0</p><p>This problem is all about multiplications, more and more multiplications. It is a game of multiplications of factorials.</p><p>The Problem:<br>You will be given three lists of numbers: A, B and C. You have to take the factorials of all the numbers in each list and multiply them to get ProFact(A), ProFact(B), ProFact(C). Then report which product is the largest.</p><p>For example, consider the lists A = {2, 4, 7}, B = {0, 1, 9} and C = {2, 3, 5, 5}. Then,</p><p>ProFact(A) = 2! <em> 4! </em> 7! = 241, 920<br>ProFact(B) = 0! <em> 1! </em> 9! = 362, 880<br>ProFact(C) = 2! <em> 3! </em> 5! * 5! = 172,800</p><p>So, the largest product for this example is ProFact(B).</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>The first input line contains a positive integer, n, indicating the number of test cases. Each test case consists of four input lines. The first line consists of three positive integers providing, respectively, the size for the lists A, B and C. The last three lines contain, respectively, the elements (non-negative integers) in lists A, B and C.</p><p>All the values in the input file will be less than 2,501.</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>For each test case, output “Case #t: h” in a line, where t is the case number (starting with 1) and h is the list name with the highest product. If two or three lists are tied for the highest product, print “TIE”. Follow the format illustrated in Sample Output. Assume that, if the pairwise product values differ, then the relative difference of these products will differ by at least 0.01% of the largest product.</p><p>样例输入<br>3<br>3 3 4<br>2 4 7<br>0 1 9<br>2 3 5 5<br>2 2 2<br>2 3<br>3 2<br>2 2<br>3 3 3<br>1 3 5<br>2 4 6<br>1 4 7<br>样例输出<br>Case #1: B<br>Case #2: TIE<br>Case #3: C</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思很好理解，就是给你三组数，让你比较哪组数里面所有数的阶乘和最大。保证数据小于2500。<br>阶乘是一个很大的数，如果直接暴力计算肯定是存不下的。所以我们取一个对数，因为我们只需要比较大小，不需要进一步计算。<br>因为<script type="math/tex">\log (a \times b)=\log a+\log b</script>,并且数据最大也就2500，所以我们首先可以通过递推预处理出每一个值的阶乘所对应的对数。然后后面的相乘也直接对数相加即可。<br>因为精度问题，题目中也说到了，所以我们比较大小的时候不能直接用等于判断（WA死我了），看两个数是否相等我们只需要看他们的差和1e-6的大小关系即可~</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 3e3+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;const double ohuo = 1e-6;int d[4][2]={1,0,0,1,-1,0,0,-1};long double fac[maxn];int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    fac[1]=0;    for(int i=2;i&lt;=2510;i++){        fac[i]=fac[i-1]+log(i);        // cout&lt;&lt;fac[i]&lt;&lt;endl;    }//预处理    int t,a,b,c,mid;    cin&gt;&gt;t;    for(int ca=1;ca&lt;=t;ca++){        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        double x=0,y=0,z=0;        while(a--){            cin&gt;&gt;mid;            x+=fac[mid];        }        while(b--){            cin&gt;&gt;mid;            y+=fac[mid];        }        while(c--){            cin&gt;&gt;mid;            z+=fac[mid];        }        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca&lt;&lt;&quot;: &quot;;        if(x-y&gt;ohuo&amp;&amp;x-z&gt;ohuo){            cout&lt;&lt;&quot;A&quot;;        }        else if(y-x&gt;ohuo&amp;&amp;y-z&gt;ohuo){            cout&lt;&lt;&quot;B&quot;;        }        else if(z-y&gt;ohuo&amp;&amp;z-x&gt;ohuo){            cout&lt;&lt;&quot;C&quot;;        }        else{            cout&lt;&lt;&quot;TIE&quot;;        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      比较水的一道数学题，这种做题方法得记录一下
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="数学" scheme="/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于我的视线，谈谈我对现在网络环境的一些看法</title>
    <link href="/2020/05/17/licenses/"/>
    <id>/2020/05/17/licenses/</id>
    <published>2020-05-17T11:41:34.000Z</published>
    <updated>2020-10-20T14:57:55.788Z</updated>
    
    <content type="html"><![CDATA[<p>构思的时候想法很多，到了真正下手的时候却又不知道从何说起。本文仅代表个人观点，杠精勿扰。</p><p>从一开始维护自己的个人博客，到后来的各种转大佬博客。总能看到一些博客写的满满的版权声明，免责声明等等等等。甚至有的还会在博客一个地方写上自己引用的所有图片的出处。那时候什么都不懂，觉得挺高大上的，想给自己加上但是又不知道怎么写。现在不一样了，现在什么都还是不懂，但是已经不想加了。</p><div class="note warning"><p>我为什么不用CSDN或者博客园？</p></div><p>不得不说，在百度权重，收录这方面，CSDN和博客园做的是真棒，当然还有简书等，不再一一列举。下图为例<br><a href="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589716643218.webp" data-fancybox="images" data-caption="1589716643218.webp" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589716643218.webp" class="img-shadow img-margin"></center></a><br></p><p class="p center small">图为某次cf题解我被CSDN和博客园夹在中间</p><p></p><p>倒也不是说我写的文章质量比他们的都高很多，只不过是我不信只有我一个个人博客的用户写了这篇题解。而国内大部分用户还是用的百度，这就很🚗🥚了。</p><p>还有就是博客园和CSDN的“原创”，不是说所有原创都有问题，但是每当我搜一个东西，好，搜了一下，基本是这俩，点开排名第一的，嗯，说的不错，但是没解决我的问题，往下看看吧，第二个，这不跟第一个一样吗？往下看，大部分都是一个板子出来的，而且更有甚者直接是粘贴过来的，格式，链接，全都不变就过来了。还有某些采集站，点进去，代码都不全。</p><p>前段时间参加了腾讯粑粑的原创作者分享计划，一开始还没什么，后来三天内爬了我一百五十多篇文章，爬倒是挺好的，我们也是互惠。很神奇的是腾讯云那的文章不论是百度还是谷歌，排名碾压我（就算按先来后到也不是这样吧），不过毕竟是自己的文章，这也是好事。但是就这一爬，第二天我就看到了采集站上源自我博客的文章。我向腾讯云的技术人员询问，得到的答复是，腾讯云专栏的文章不会被爬走，除非采集站的人手动粘贴复制。哦，一个采集站的，还手动粘贴复制，我信。那个采集站，我找到了站长的联系方式，让他修改原出处，他回应的也不错，直接将文章删除了。</p><p>确实，我的博客下面写着<code>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</code>。我们看一下这个协议的内容<br></p><p class="p center">这是一份普通人可以理解的许可协议概要 (但不是替代) 。 免责声明.</p><p></p><p class="p center">您可以自由地：</p><p class="p center">共享 — 在任何媒介以任何形式复制、发行本作品</p><p class="p center">演绎 — 修改、转换或以本作品为基础进行创作</p><p class="p center">只要你遵守许可协议条款，许可人就无法收回你的这些权利。</p><p>对，这个协议我许可。但是那些个直接cv“转载”就放到网络上的，个人认为实在是污染环境。但是我没办法啊，我也改过一段时间，必须联系我获得许可才能转载，后来还是算了。毕竟有很多小伙伴的转载方式我很爱，而且也没哪个采集站会闲的没事爬我这个小站的文章。<br>你转载的时候加上自己的使用心得或者自己的看发，这才是允许转载的原意，而不是照搬。（某些类型除外，此处指小说等文章。</p><p>说完了博客，在说说开源这件事。<br>刚开始接触博客，就接触到了GitHub，GitHub 是一个面向开源及私有软件项目的托管平台。其上的开源软件，代码数不胜数。<br>就拿我的博客框架<code>Hexo</code>来说，这个框架真的没话说，好用。但是每个由他为框架的博客页脚会默认存在一个<code>Powered by Hexo</code>然后一个超链接到它的GitHub库/官网。<br>在我刚使用博客的时候，什么都不懂的时候，觉得这个很难看，费尽吃奶的劲也想给删掉它，如我所愿，网上的教程数不胜数。<br>后来，慢慢的，我接触的越多，换了个主题，将页脚的Hexo和主题字段都保留了下来，即使现在我已经学会了如何去删掉他们。<br>我专门看了一下Hexo的开源许可证，它采用的是<code>MIT</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589718059881.webp" data-fancybox="images" data-caption="1589718059881.webp" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/imgcdn/1589718059881.webp" class="img-shadow img-margin"></center></a><br>确实没有专门说关于这个标识，甚至hexo还是某些主题似乎还内置了配置项用来取消这个标识。确实，这些开源的代码都允许你随意修改使用，但是，作者尽心尽力的开发的东西，放个类似于logo的东西，你都不允许它的存在，引流是一方面。个人认为这也会减弱开发者的创作热情。<br>所以，我现在自豪的在页脚加上了<code>Powered by Hexo</code>和<code>Theme Sakura  by Mashiro&amp;Hojun</code></p><p>当然，这也不是大家必须做的。</p><div class="note quote"><p>开源软件（英语：open source software，缩写：OSS）又称开放源代码软件，是一种源代码可以任意获取的计算机软件，这种软件的著作权持有人在软件协议的规定之下保留一部分权利并允许用户学习、修改以及以任何目的向任何人分发该软件。</p></div><p>我只觉得，即使是开源软件，用着别人做的，不是非得要有感恩的心，那太扯了，但是起码有那么一点点的感谢或者是尊重，而不是说拿过来代码，人家的声明一删就自己用。</p><p>再次重申，以上仅为个人观点，不论对错。如果你不喜欢我说的话，且当我一人在胡言乱语吧。</p><p>反正我是不会很多的去使用csdn，博客园还挺好，csdn我真的没话说。我也不需要他们为我引流，就做个小站站长，有人需要了解什么只有我这有的东西让他能搜到我就行。安安静静的做个咸鱼，守住自己的这片“净土”。</p>]]></content>
    
    <summary type="html">
    
      闲来无事，抒发一下感情，简单谈一下自己对开源以及关于博客权益的一些看法。
    
    </summary>
    
      <category term="Life" scheme="/categories/Life/"/>
    
    
      <category term="lisense" scheme="/tags/lisense/"/>
    
      <category term="blog" scheme="/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>团结就是力量</title>
    <link href="/2020/05/14/nowcoder14411/"/>
    <id>/2020/05/14/nowcoder14411/</id>
    <published>2020-05-14T09:40:07.000Z</published>
    <updated>2020-10-20T14:57:58.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="团结就是力量"><a href="#团结就是力量" class="headerlink" title="团结就是力量"></a>团结就是力量</h1><div class="note link green"><p>Link: <a href="https://ac.nowcoder.com/acm/problem/14411" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/14411</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>从小老师就教育我们，一根筷子容易折断，而一捆筷子不容易折断。<br>因为要出战世界杯，我们需要考虑派一只队伍出战，而我们希望出战的队伍的团结力最大。<br>而一个队伍的团结力取决于每个人的性格，每个人都有一个性格基因【（由字符串表示），比如小明的性格基因为：abbcde】，性格基因的排列方式是可以通过一个人的后天培养而改变的，其改变方式就是类似于循环，【小明的性格基因为：abbcde，他可以变成：bbcdea，bcdeab，cdeabb，deabbc，eabbcd】 。<br>一个队伍中如果最多有x个人的性格基因可以完全相等的话，那么这个队伍的团结力就是x。<br>比如一个队伍有五个人：<br>小明：abbcde<br>小红：bbcdea<br>大明：cdeabb<br>大红：efg<br>小紫：fge<br>明显小明小红和大明的性格基因可以变成相等的，大红和小紫的性格基因可以变成相等的， 这个最多有3个人的性格基因可以完全相等的，所以这个五人队伍的团结力就是3；</p><p>现在已知可以出战的人数为n个，每个人都有一个性格基因字符串，而作为一只队伍出战的话，需要队伍中的每个人都互相达成共识。同时也已知m个信息，每个信息是：<br>a想要和b一起出战【注意，这里只是a的一厢情愿】，只有当a想要和b一起出战，并且b也想要和a一起出战的时候，两个人才能一起出战。想要一起出战是可以具有传递性的，比如a想要和b一起出战，b想要和c一起出战的话，那么a也可以想要和c一起出战。</p><p>我们肯定希望派出的队伍的团结力最大，请计算出这个最大团结力。  </p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>本题包含多组数据，第一行输入两个数字n，m，分别表示一共有n个人，以及m个出战信息 。<br>接下来n行，每行输入一个字符串，表示每个人的性格基因。<br>再接下来m行，每行两个编号x，y，表示x想要和y出战<br>数据范围：<br>5&lt;=n&lt;=100000<br>1&lt;=m&lt;=100000<br>1&lt;=x,y&lt;=n<br>每个数据的字符串长度和不超过100000</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>每组数据输出一行，表示最大团结力。</p><p>示例1<br>输入<br>5 5<br>abbcde<br>bbcdea<br>cdeabb<br>efg<br>fge<br>1 2<br>2 3<br>3 4<br>4 5<br>5 1<br>6 7<br>abbcde<br>bbcdea<br>cdeabb<br>efg<br>fge<br>gef<br>1 2<br>2 3<br>3 1<br>4 5<br>5 6<br>6 4<br>2 4<br>输出<br>3<br>3<br>说明<br>第一个样例题干中有所描述。这里1想和2出战，2想和3出战，3想和4出战，4想和5出战，5又想和1出战，那么就相当于每个人都想要互相一起出战，所以这就是一个队伍。<br>第二个样例中，123号三个人是一个队伍，456号是一个队伍，虽然2想和4一起出战，但是已知m条信息中，不能构成4想和2出战的信息出来，所以六个人不能变成一个队伍。</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思就是给你一些人，告诉你单向选择的结果，并且a选b，b选c，等于a选c。每个人都有一个字符串，可以以循环的方式随意变换。每组成员的团结力就是字符串相等的个数（任意变换后）。当且仅当两个人互相选了才可以成组。</p><p>首先解决分组的问题，直接用tarjan缩点就可以了。<br>然后就是团结力的问题了，我们可以给每个字符串设定一个规则，将每个字符串以里面字典序最小的元素做开头，作为变换的终点。然后统计相同组相同字符串的个数即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pair#define mem(name,val) memset(name,val,sizeof(name));const int maxn = 1e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int d[4][2]={1,0,0,1,-1,0,0,-1},n,m;string s[maxn];vector&lt;int&gt; g[maxn];vector&lt;string&gt; final[maxn];int dfn[maxn],color[maxn],low[maxn],cnt,top,sta[maxn],vis[maxn],scc;void init(){    for(int i=0;i&lt;=n;i++)   g[i].clear(),final[i].clear();    mem(dfn,0);mem(low,0);mem(sta,0);mem(vis,0);mem(color,0);    top=scc=0;    cnt=1;}void dfs(int u){    vis[u]=1;    low[u]=dfn[u]=cnt++;    sta[++top]=u;    for(auto v:g[u]){        if(vis[v]==0)   dfs(v);        if(vis[v]==1)   low[u]=min(low[u],low[v]);    }    if(dfn[u]==low[u]){        scc++;        do{            low[sta[top]]=scc;            color[sta[top]]=scc;            vis[sta[top]]=-1;        }        while(sta[top--]!=u);    }}int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    while(cin&gt;&gt;n&gt;&gt;m){        init();        for(int i=1;i&lt;=n;i++){            string ss;            cin&gt;&gt;ss;            int l=ss.size(),pos=0;char begin=ss[0];            for(int j=1;j&lt;l;j++){                if(ss[j]&lt;=begin){                    pos=j;                    begin=ss[j];                }            }            string mid=&quot;&quot;;            for(int j=pos,tot=0;tot&lt;l;j++,tot++){                mid+=ss[j%l];            }            ss=mid;            s[i]=mid;        }        for(int i=1,x,y;i&lt;=m;i++){            cin&gt;&gt;x&gt;&gt;y;            g[x].pb(y);        }        for(int i=1;i&lt;=n;i++){            if(!dfn[i]){                dfs(i);            }        }        for(int i=1;i&lt;=n;i++){            final[color[i]].pb(s[i]);        }        int ans=0;        for(int i=1;i&lt;=scc;i++){            map&lt;string,int&gt; ma;             for(auto j:final[i]){                ma[j]++;            }            for(auto ohuo:ma){                ans=max(ans,ohuo.second);            }        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      tarjan缩点专题的第三题，自闭了
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="nowcoder" scheme="/tags/nowcoder/"/>
    
      <category term="tarjan" scheme="/tags/tarjan/"/>
    
  </entry>
  
  <entry>
    <title>Picgo上传到GitHub莫名其妙的出错后，我选择自己实现上传功能</title>
    <link href="/2020/05/14/88picgo/"/>
    <id>/2020/05/14/88picgo/</id>
    <published>2020-05-14T02:42:48.000Z</published>
    <updated>2020-10-20T14:57:55.750Z</updated>
    
    <content type="html"><![CDATA[<div class="note guide blue"><p>使用GitHub做图床之后，上传是个比较麻烦的事。picgo是第一选择，但是最近不知道是什么原因，总是会莫名其妙的出错，在网上也搜不到任何解决方案，似乎官方给的回应就是GitHub的原因。那自然也是我无法干涉解决的了，所以还是自己来吧。自己动手丰衣足食</p></div><p>正好前两天在nb学长的帮助教育下用过GitHub上传文件的api，所以用起来也是轻车熟路了。<br>这不是教程，只是给出一个参考。另外，picgo很好用，就是我用不好。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>我引用了<code>jquery</code></p><pre><code class="lang-html">&lt;script src=&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>首先要有一个可以上传文件的按钮（或者其他之类的）</p><pre><code class="lang-html">&lt;input type=&quot;file&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>accept里面填入的就是选择文件的时候可选的格式，如果不填默认所有都可以</p><p>但是这个按钮的样式，不是怎么好看，所以可以改成这样</p><pre><code class="lang-html">&lt;div style=&quot;font-size: 30px;display: inline; cursor: pointer&quot; onclick=&quot;myimg.click()&quot;&gt;🚢&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;myimg&quot; style=&quot;visibility: hidden;&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>先把这个文件选择的按钮通过<code>visibility: hidden;</code>隐藏起来，然后通过另一个元素的<code>onclick</code>事件模拟点击了选择文件的按钮，这样就会很好看。🚢这个你可以随意更换为你想要的。</p><p>选择文件的弄好了，接着就是上传了。<br>GitHub的api说必须将文件转换成base64编码的格式才支持上传，所以我们首先要把选择的图片转换为base64编码的形式，然后直接调用api上传既可。<br>但是base64我们还得处理一下，因为转换出来的前面会带着data一些属性，用正则（nb学长帮我搞的）直接把前面的去掉，然后用substring获得图片本来的格式。<br>这里我是用时间戳重命名图片的，很随意，如果你要用别的也可以</p><pre><code class="lang-JavaScript">function uploadimg(file){      var timestamp=new Date().getTime();//获取时间戳      var nameofimg=timestamp+&quot;.&quot;+houzhui;//以事件戳重命名      var picurl=&quot;https://cdn.jsdelivr.net/gh/“GitHub用户名”/“GitHub存放图片的仓库名”/&quot;+nameofimg;    var settings = {    &quot;url&quot;: &quot;https://api.github.com/repos/“GitHub用户名”/“GitHub存放图片的仓库名”/contents/&quot;+nameofimg,    &quot;method&quot;: &quot;PUT&quot;,    &quot;timeout&quot;: 0,    &quot;headers&quot;: {        &quot;Authorization&quot;: &quot;Bearer “你的GitHub具有读写功能的token（怎么弄？百度去）”&quot;,        &quot;Content-Type&quot;: &quot;text/plain&quot;    },    &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;upload\&quot;,\r\n  \&quot;content\&quot;: \&quot;&quot;+ file +&quot;\&quot;\r\n}&quot;,    };    $.ajax(settings).done(function (response) {        imgurlmd=&quot;Markdown:![](&quot;+picurl+&quot;)&quot;;//markdown格式的链接        url=&quot;Imgurl:&quot;+picurl;//图片原链接        my=&quot;My:{% fb_img "+picurl+"  "+nameofimg+" %}&quot;;//自定义的格式，这里是我的自定义        var final=&quot;&lt;li&gt;&quot;+imgurlmd+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+url+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+my+&quot;&lt;/li&gt;&quot;;        document.getElementById(&quot;neirong&quot;).innerHTML=final;//写道html里面    });}function imgChange(img) {    const reader = new FileReader();    reader.onload = function (ev) {        var imgFile =ev.target.result;//imgFile就是图片的base64编码        base64url=imgFile.replace(/(.*)?,/,&#39;&#39;);//用正则消除前面的data之类的字符        // console.log(imgFile);        houzhui = imgFile.substring( imgFile.indexOf(&quot;/&quot;) + 1, imgFile.indexOf(&quot;;&quot;) );//获取图片原本的格式        uploadimg(base64url);//上传    }    reader.readAsDataURL(img.files[0]);}</code></pre><p>以上代码中用<code>“”</code>包含的都是你自己的信息</p><p>上传的代码有了，再将上传代码的函数和选择文件弄在一起，然后为返回的链接找一个位置就好了</p><pre><code class="lang-html">&lt;div style=&quot;font-size: 30px;display: inline; cursor: pointer&quot; onclick=&quot;myimg.click()&quot;&gt;🚢&lt;/div&gt;&lt;div id=&quot;neirong&quot;&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;myimg&quot; onchange=&quot;imgChange(this)&quot; style=&quot;visibility: hidden;&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>这样就可以了~关于html页面可以根据自己的需要进行美化</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="lang-html">&lt;script src=&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;function uploadimg(file){      var timestamp=new Date().getTime();//获取时间戳      var nameofimg=timestamp+&quot;.&quot;+houzhui;//以事件戳重命名      var picurl=&quot;https://cdn.jsdelivr.net/gh/“GitHub用户名”/“GitHub存放图片的仓库名”/&quot;+nameofimg;    var settings = {    &quot;url&quot;: &quot;https://api.github.com/repos/“GitHub用户名”/“GitHub存放图片的仓库名”/contents/&quot;+nameofimg,    &quot;method&quot;: &quot;PUT&quot;,    &quot;timeout&quot;: 0,    &quot;headers&quot;: {        &quot;Authorization&quot;: &quot;Bearer “你的GitHub具有读写功能的token（怎么弄？百度去）”&quot;,        &quot;Content-Type&quot;: &quot;text/plain&quot;    },    &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;upload\&quot;,\r\n  \&quot;content\&quot;: \&quot;&quot;+ file +&quot;\&quot;\r\n}&quot;,    };    $.ajax(settings).done(function (response) {        imgurlmd=&quot;Markdown:![](&quot;+picurl+&quot;)&quot;;//markdown格式的链接        url=&quot;Imgurl:&quot;+picurl;//图片原链接        my=&quot;My:{% fb_img "+picurl+"  "+nameofimg+" %}&quot;;//自定义的格式，这里是我的自定义        var final=&quot;&lt;li&gt;&quot;+imgurlmd+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+url+&quot;&lt;/li&gt;&quot;+&quot;&lt;li&gt;&quot;+my+&quot;&lt;/li&gt;&quot;;        document.getElementById(&quot;neirong&quot;).innerHTML=final;//写道html里面    });}function imgChange(img) {    const reader = new FileReader();    reader.onload = function (ev) {        var imgFile =ev.target.result;//imgFile就是图片的base64编码        base64url=imgFile.replace(/(.*)?,/,&#39;&#39;);//用正则消除前面的data之类的字符        // console.log(imgFile);        houzhui = imgFile.substring( imgFile.indexOf(&quot;/&quot;) + 1, imgFile.indexOf(&quot;;&quot;) );//获取图片原本的格式        uploadimg(base64url);//上传    }    reader.readAsDataURL(img.files[0]);}&lt;/script&gt;&lt;div style=&quot;font-size: 30px;display: inline; cursor: pointer&quot; onclick=&quot;myimg.click()&quot;&gt;🚢&lt;/div&gt;&lt;div id=&quot;neirong&quot;&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;myimg&quot; onchange=&quot;imgChange(this)&quot; style=&quot;visibility: hidden;&quot; accept=&quot;image/png,image/gif,image/jpeg&quot;&gt;</code></pre><p>好了，这样就完成了自己写一个页面替代picgo的功能了。</p><h2 id="最后要说的话"><a href="#最后要说的话" class="headerlink" title="最后要说的话"></a>最后要说的话</h2><p>这个页面可以本地使用，并且推荐本地使用。<br>如果你想让别人跟你一起使用并且想要上传到GitHub pages的话，你需要将你的token换一种形式存在于代码中，比如说加密。然后再解密然后使用。即不能让你的token以明文形式存在，否则会被GitHub检测到然后删除你的这个token以至于上传api出现权限不足的报错。<br>本地自己用就没那么多事啦~</p>]]></content>
    
    <summary type="html">
    
      通过调用GitHub提供的api上传图片
    
    </summary>
    
      <category term="Tutorial" scheme="/categories/Tutorial/"/>
    
    
      <category term="Github" scheme="/tags/Github/"/>
    
      <category term="图床" scheme="/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="JavaScript" scheme="/tags/JavaScript/"/>
    
      <category term="Html" scheme="/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>COVID-19与我</title>
    <link href="/2020/05/14/COVID-19/"/>
    <id>/2020/05/14/COVID-19/</id>
    <published>2020-05-13T23:56:03.000Z</published>
    <updated>2020-10-20T14:57:55.767Z</updated>
    
    <content type="html"><![CDATA[<div class="note radiation red"><p>新型冠状病毒肺炎（Corona Virus Disease 2019，COVID-19），简称“新冠肺炎”，世界卫生组织命名为“2019冠状病毒病” ，是指2019新型冠状病毒感染导致的肺炎。2019年12月以来，湖北省武汉市部分医院陆续发现了多例有华南海鲜市场暴露史的不明原因肺炎病例，现已证实为2019新型冠状病毒感染引起的急性呼吸道传染病。—— 百度百科</p></div><p>就在疫情刚开始的那段时间，还没有很严重的时候还和我爸一起去我们这里新建的“古城”转悠了一圈（当然是戴着口罩的），那是年三十。</p><p>大年三十的晚上已过去，第二天就受到了各种通知，大概意思就是不让出去玩，不让走亲戚。只能在家呆着。这时疫情的严重性正在逐渐上升。那一段时间，街上基本都是空空的。然后就真的没有走亲戚，也没有出去玩。也忘了在家呆了有多久，到了该开学的时间，没有一个学校敢开学。不开学怎么办呢？在家上网课。</p><p>刚开始上网课的那段时间，一大堆的学习app占满了手机屏幕（直到现在还是。不过我现在也基本上没怎么上课，没怎么交作业。网课也太令人讨厌了。</p><p>其实说到COVID-19对我最大的影响之一，就是可能无法如期举行的ICPC，就如同一个赌徒，赌上了所有的钱，赌局失效了，庄家跑了那样子。亏得血本无归，是，搞算法也是为了充实自身，为以后打基础，但谁不想多拿几个奖？更何况对于我这种本来就没多少奖的蒟蒻玩家。在这里只能希望疫情早点结束，彻底地结束。现在很大的概率表面，我会被迫提前退役。</p><p>而且因为这个疫情，我们协会的下一届也受到了影响。无法面对面的讲课，无法知道每个同学的真实水平，很多很多的未知，不只是下一届，还有现在这一届，太多的不确定，导致管理方面极大的不易，其实也不能全怪疫情，也是我的管理能力太弱了。我可不想教练与学长苦苦经营了十多年的协会毁在我这一届，那就是千古罪人了啊。</p><p>这次<strong>寒假</strong>，放的时间应该是最长的了。二月十几号就该是开学的日子，直到今天开学还遥遥无期，每次都会有消息说下个月可能会开学，然后到了下个月就毫无消息，接着就是下一个下个月。毕竟学校同学密集，危险性是极高的。</p><p>呆在家的这段时间，随着爸妈的复工，我一个人在家的次数越来越多，他们忙没时间回来做饭，锻炼的我也会做饭了。这个必须夸自己一波。之前只会泡泡面，太磕碜了。</p><p class="p center">希望疫情早日过去，我们恢复正常生活</p>]]></content>
    
    <summary type="html">
    
      还记得疫情最开始的时候，看到别人博客说道自己丢了工作还替他感到惋惜，现在轮到了替自己惋惜。
    
    </summary>
    
      <category term="Life" scheme="/categories/Life/"/>
    
    
      <category term="Life" scheme="/tags/Life/"/>
    
      <category term="COVID-19" scheme="/tags/COVID-19/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加可实时发布的说说界面 | Artitalk.js</title>
    <link href="/2020/05/11/artitalk/"/>
    <id>/2020/05/11/artitalk/</id>
    <published>2020-05-11T01:45:23.000Z</published>
    <updated>2020-10-20T14:57:55.750Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote"><p>Artitalk，前hexo-shuoshuo，重铸了一下，使用方法其实差不多，但是好多朋友都说看不太懂，所以再开（水）一篇文章介绍一下它的使用吧。注：本文只讲解简单使用。关于本js的详细介绍请移步文档：<a href="https://artitalk.js.org/" target="_blank" rel="noopener">https://artitalk.js.org/</a></p></div><h2 id="关于Leancloud"><a href="#关于Leancloud" class="headerlink" title="关于Leancloud"></a>关于Leancloud</h2><p>（这部分跟之前教程一样，如果你只是更新，直接跳到新建即可。<br>这里我们要求使用<a href="https://console.leancloud.app/login.html#/signup" target="_blank" rel="noopener">leancloud国际版</a>注册，因为国际版不需要绑定备案的域名<br>注册结束后首先找到账号设置，绑定邮箱和手机号。这一步是必须的，否则无法创建应用。邮箱和手机号都有临时的，所以也不难。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc1.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc1.webp" class="img-shadow img-margin"></center></a></p><p>绑定成功之后，点击创建应用，并将应用名字设置为<code>shuoshuo</code><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc2.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc2.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lcc2.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lcc2.webp" class="img-shadow img-margin"></center></a></p><p>创建之后点击应用跳转到控制台<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc3.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc3.webp" class="img-shadow img-margin"></center></a></p><p>在设置中找到应用keys中的<code>appId</code>和<code>appKey</code>记下来，或者页面一直开着。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc4.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc4.webp" class="img-shadow img-margin"></center></a></p><p>在<code>leancloud</code>的存储中添加<code>class</code>，命名为<code>shuoshuo</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/lc5.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/lc5.webp" class="img-shadow img-margin"></center></a></p><p>然后在你新建的应用中找到<code>结构化数据</code>下的<code>用户</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234538.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234538.webp" class="img-shadow img-margin"></center></a></p><p>然后点击<code>添加用户</code>，输入你想使用的<code>用户名</code>以及<code>密码</code>。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234719.webp" data-fancybox="images" data-caption="ohuo" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417234719.webp" class="img-shadow img-margin"></center></a></p><p>接着回到<code>结构化数据-&gt;shuoshuo-&gt;权限</code>，在<code>Class访问权限</code>中将<code>add_fields</code>以及<code>create</code>权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将<code>delete</code>和<code>update</code>也设置为跟它们一样的权限。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235209.webp" data-fancybox="images" data-caption="20200417235209" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235209.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235312.webp" data-fancybox="images" data-caption="20200417235312" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200417235312.webp" class="img-shadow img-margin"></center></a></p><p>最后将<code>_User</code>中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据。</p><p>到这里<code>leancloud</code>的设置就告一段落了。</p><h2 id="新建说说界面"><a href="#新建说说界面" class="headerlink" title="新建说说界面"></a>新建说说界面</h2><ol><li>在<code>..\&#39;blogname&#39;\source</code>中新建一个文件夹，命名为<code>shuoshuo</code>（或者其它你想用的）</li><li>在刚才新建的文件夹中新建<code>index.md</code>，文件内容为</li></ol><pre><code class="lang-markdown">---title: 说说（或者其它你想用的）comments: false (如果你的博客中使用了valine作为评论系统，这一句一定要加上，否则会出错)---&lt;script src=&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;body&gt;    &lt;script&gt;    var img=&quot;&quot;;    var appID=&quot;&quot;;    var appKEY=&quot;&quot;;    var per=&quot;&quot;;    var username=&quot;&quot;;    &lt;/script&gt;    &lt;div id=&quot;lazy&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;artitalk&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/artitalk&quot;&gt;&lt;/script&gt; //调用artitalk&lt;/body&gt;</code></pre><p>关于配置项的说明<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200511095805.png" data-fancybox="images" data-caption="20200511095805" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200511095805.png" class="img-shadow img-margin"></center></a></p><p>这样你再<code>hexo g</code>之后<strong>应该</strong>就可以了。对没错就是这样。多简单啊。</p>]]></content>
    
    <summary type="html">
    
      通过Artitalk.js添加一个说说页面。Artitalk，前hexo-shuoshuo，重铸了一下，使用方法其实差不多，但是好多朋友都说看不太懂，所以再开（水）一篇文章介绍一下它的使用吧。
    
    </summary>
    
      <category term="Life" scheme="/categories/Life/"/>
    
    
      <category term="html" scheme="/tags/html/"/>
    
      <category term="javascript" scheme="/tags/javascript/"/>
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>一步步带你通过Ajax+Github提供的api 实现前端剪切板图片上传</title>
    <link href="/2020/05/08/artiimg/"/>
    <id>/2020/05/08/artiimg/</id>
    <published>2020-05-08T10:33:33.000Z</published>
    <updated>2020-10-20T14:57:55.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过api上传文件"><a href="#通过api上传文件" class="headerlink" title="通过api上传文件"></a>通过api上传文件</h2><div class="note warning"><p>这方面刚刚接触，只给出傻瓜式操作2333。强推Postman，调试api太好用了.如果不想跟着一起体验Postman的舒爽，可以直接跳到jquery代码</p></div><p><a href="https://www.postman.com/" target="_blank" rel="noopener">点我下载或在线使用Postman</a>，推荐下载后使用。</p><p>在GitHub的api中，有关于文件上传的接口<a href="https://developer.github.com/v3/repos/contents/" target="_blank" rel="noopener">Create or update a file</a></p><p>api的url格式</p><pre><code>PUT /repos/:owner/:repo/contents/:path</code></pre><p>在Postman里面我们新建一个请求<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184058.webp" data-fancybox="images" data-caption="20200508184058" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184058.webp" class="img-shadow img-margin"></center></a></p><p>首先改成PUT，然后输入url</p><pre><code>https://api.github.com/repos/:owner/:repo/contents/:path</code></pre><p>在body下使用raw添加信息(注意，GitHub的api强调必须把文件进行 base64 编码才能上传)</p><pre><code>//这是官网上的示例，我们只需要用message和content即可{  &quot;message&quot;: &quot;my commit message&quot;,  &quot;committer&quot;: {    &quot;name&quot;: &quot;Monalisa Octocat&quot;,    &quot;email&quot;: &quot;octocat@github.com&quot;  },  &quot;content&quot;: &quot;bXkgbmV3IGZpbGUgY29udGVudHM=&quot;}//可以拿下面这个做测试用{  &quot;message&quot;: &quot;test&quot;,  &quot;content&quot;: &quot;aGVsbG8gd29ybGQ=&quot;}</code></pre><p><code>aGVsbG8gd29ybGQ=</code>就是<code>Hello world</code>的base64编码后的形式<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184709.webp" data-fancybox="images" data-caption="20200508184709" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508184709.webp" class="img-shadow img-margin"></center></a></p><p>我们还需要一步验证，GitHub可以采用token验证。<br><a href="https://github.com/settings/tokens" target="_blank" rel="noopener">点我生成GitHub的token</a>，我们这里只需要读写权限即可。不需要更多别的了，注意这个token只出现一次，确保已经粘贴好了再关闭这个页面。<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185206.webp" data-fancybox="images" data-caption="20200508185206" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185206.webp" class="img-shadow img-margin"></center></a><br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185341.webp" data-fancybox="images" data-caption="20200508185341" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185341.webp" class="img-shadow img-margin"></center></a></p><p>在Postman中的<code>Authorization</code>下的type选择<code>OAuth 2.0</code>，将你的token粘贴进去<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185446.webp" data-fancybox="images" data-caption="20200508185446" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185446.webp" class="img-shadow img-margin"></center></a></p><p>然后<code>send</code>,如果成功的话（跟着上面的来就不会出错（应该不会）），Postman中的body中会是这样的<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185718.webp" data-fancybox="images" data-caption="20200508185718" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/20200508185718.webp" class="img-shadow img-margin"></center></a></p><p>这个时候你在去你的上传的库中就可以看到你刚才上传的文件，比如说我这里是一个写着<code>Hello world</code>的readme.md<br><a href="https://cdn.jsdelivr.net/gh/drew233/cdn/ajaxgithub.webp" data-fancybox="images" data-caption="ajaxgithub" target="_blank" rel="noopener"><center><img src="https://cdn.jsdelivr.net/gh/drew233/cdn/ajaxgithub.webp" class="img-shadow img-margin"></center></a></p><p>这就说明你成功通过api向GitHub传了文件</p><h2 id="jquery代码"><a href="#jquery代码" class="headerlink" title="jquery代码"></a>jquery代码</h2><p>Postman支持自动生成访问api的代码。支持语言很多，这里我选择得时jquery的<br>如果你是上一步一起做过来的，直接生成代码就可自用。</p><pre><code class="lang-javascript">var settings = {  &quot;url&quot;: &quot;https://api.github.com/repos/Drew233/test/contents/test/readme.md&quot;,  &quot;method&quot;: &quot;PUT&quot;,  &quot;timeout&quot;: 0,  &quot;headers&quot;: {    &quot;Authorization&quot;: &quot;Bearer :Your token&quot;,    &quot;Content-Type&quot;: &quot;text/plain&quot;  },  &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;test\&quot;,\r\n  \&quot;content\&quot;: \&quot;aGVsbG8gd29ybGQ=\&quot;\r\n}&quot;,};$.ajax(settings).done(function (response) {  console.log(response);});</code></pre><p>通过观察我们不难发现</p><ul><li>url即上面我们访问的api的url</li><li>Authorization中的Bearer后面就是我们的token</li><li>data对应的就是官网中所给的发送api请求时候需要的信息</li></ul><h2 id="接听粘贴事件并将剪切板图片转换为base64编码后上传"><a href="#接听粘贴事件并将剪切板图片转换为base64编码后上传" class="headerlink" title="接听粘贴事件并将剪切板图片转换为base64编码后上传"></a>接听粘贴事件并将剪切板图片转换为base64编码后上传</h2><pre><code class="lang-javascript">function uploadimg(file){  var settings = {      &quot;url&quot;: &quot;&quot;,      &quot;method&quot;: &quot;PUT&quot;,      &quot;timeout&quot;: 0,      &quot;async&quot;: true,      &quot;headers&quot;: {        &quot;Authorization&quot;: ,        &quot;Content-Type&quot;: &quot;text/plain&quot;      },      &quot;data&quot;: &quot;{\r\n  \&quot;message\&quot;: \&quot;&quot; + window.location.host + &quot;\&quot;,\r\n  \&quot;content\&quot;: \&quot;&quot; + file + &quot;\&quot;\r\n}&quot;,    };    $.ajax(settings).done(function (response) {        console.log(response);//response即为上传后返回的message    });}document.addEventListener(&#39;paste&#39;, function (event) {//检测粘贴时间  var items = event.clipboardData &amp;&amp; event.clipboardData.items;  var file = null;  if (items &amp;&amp; items.length) {      // 检索剪切板items      for (var i = 0; i &lt; items.length; i++) {          if (items[i].type.indexOf(&#39;image&#39;) !== -1) {              file = items[i].getAsFile();              var reader = new FileReader();              reader.readAsDataURL(file);//将剪切板的图片文件转为base64编码              reader.onload = function(){                  base64url=reader.result.replace(/(.*)?,/,&#39;&#39;); //通过正则表达式删除转换为base64编码后前面的部分提示信息                  uploadimg(base64url);              };              break;          }      }  }});</code></pre><p>填上对应的值即可使用。</p><h2 id="起因-amp-amp-广告"><a href="#起因-amp-amp-广告" class="headerlink" title="起因 &amp;&amp; 广告"></a>起因 &amp;&amp; 广告</h2><p>为什么会接触到这个东西呢？因为最近弄的一个js（Artitalk）需要实现这个功能。<br>欢迎大家使用：<a href="https://artitalk.js.org" target="_blank" rel="noopener">Artitalk</a></p><h2 id="一些需要注意的事"><a href="#一些需要注意的事" class="headerlink" title="一些需要注意的事"></a>一些需要注意的事</h2><p>如果你要用这个功能并且把源码上传到GitHub pages，GitHub会自动检测到你的token然后将它删除（安全措施2333。<br>解决方法就是把token加密一下，然后调用的时候解密，亲测可行~</p>]]></content>
    
    <summary type="html">
    
      之前是使用smms，使用的时候发现上传到网站，会出现跨域的错误（难以解决。所以想到了GitHub
    
    </summary>
    
      <category term="Tutorial" scheme="/categories/Tutorial/"/>
    
    
      <category term="Github" scheme="/tags/Github/"/>
    
      <category term="javascript" scheme="/tags/javascript/"/>
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Javascript+Ajax+SMMS 实现前端剪切板图片上传</title>
    <link href="/2020/05/07/imgupload/"/>
    <id>/2020/05/07/imgupload/</id>
    <published>2020-05-07T03:55:51.000Z</published>
    <updated>2020-10-20T14:57:55.787Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger"><p>本方法本地可使用，上传到网站后会出现跨域错误，最新解决方法已更新。</p></div><h2 id="需要先引入JQuery"><a href="#需要先引入JQuery" class="headerlink" title="需要先引入JQuery"></a>需要先引入JQuery</h2><pre><code class="lang-html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="监听粘贴事件"><a href="#监听粘贴事件" class="headerlink" title="监听粘贴事件"></a>监听粘贴事件</h2><pre><code class="lang-javascript">document.addEventListener(&#39;paste&#39;, function (event) {    var items = event.clipboardData &amp;&amp; event.clipboardData.items;    var file = null;    if (items &amp;&amp; items.length) {        // 检索剪切板items        for (var i = 0; i &lt; items.length; i++) {            if (items[i].type.indexOf(&#39;image&#39;) !== -1) {                file = items[i].getAsFile();                break;            }        }    }</code></pre><p>如果你复制了图片，此时的file就是你复制的图片。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>这里调用了<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>提供的上传图片的api</p><pre><code class="lang-javascript">var formData = new FormData();    formData.append(&#39;smfile&#39;,file);    $.ajax({      url: &#39;https://sm.ms/api/v2/upload&#39;,      type: &#39;POST&#39;,      data:formData,      format: &#39;json&#39;,      success: function(smms){        var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid);        if(mid.code==&quot;image_repeated&quot;){          alert(mid.images);//图片已经存在了，直接返回url        }else if(mid.code==&quot;flood&quot;){          alert(&quot;上传过于频繁，等会再试试吧~&quot;);//api限制每小时最多上传20张        }        else{          alert(mid.data.url);//上传成功后返回url        }      },      error: function(smms){         var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid.data.url);      },      cache: false,      contentType: false,      processData: false  });});</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>新建一个html页面，代码放进去即可使用</p><pre><code class="lang-html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/drew233/cdn/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;document.addEventListener(&#39;paste&#39;, function (event) {    var items = event.clipboardData &amp;&amp; event.clipboardData.items;    var file = null;    if (items &amp;&amp; items.length) {        // 检索剪切板items        for (var i = 0; i &lt; items.length; i++) {            if (items[i].type.indexOf(&#39;image&#39;) !== -1) {                file = items[i].getAsFile();                break;            }        }    }    // console.log(file); file即为剪切板中的图片    // 通过api接口上传到sm.ms    var formData = new FormData();    formData.append(&#39;smfile&#39;,file);    $.ajax({      url: &#39;https://sm.ms/api/v2/upload&#39;,      type: &#39;POST&#39;,      data:formData,      format: &#39;json&#39;,      success: function(smms){        var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid);        if(mid.code==&quot;image_repeated&quot;){          alert(mid.images);        }else if(mid.code==&quot;flood&quot;){          alert(&quot;上传过于频繁，等会再试试吧~&quot;);        }        else{          alert(mid.data.url);        }      },      error: function(smms){         var mid=eval(&#39;(&#39;+smms+&#39;)&#39;);        console.log(mid.data.url);      },      cache: false,      contentType: false,      processData: false  });});&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      因为最近在弄一个输入框的功能，发现如果可以直接cv上传图片确实很方便。查了一些资料，看了一些教程，最后也是实现了。
    
    </summary>
    
      <category term="Tutorial" scheme="/categories/Tutorial/"/>
    
    
      <category term="javascript" scheme="/tags/javascript/"/>
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>ICPC Pacific Northwest Regional Contest 2019  B. Perfect Flush</title>
    <link href="/2020/05/05/PNRC2019B/"/>
    <id>/2020/05/05/PNRC2019B/</id>
    <published>2020-05-05T01:09:45.000Z</published>
    <updated>2020-10-20T14:57:58.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-Perfect-Flush"><a href="#B-Perfect-Flush" class="headerlink" title="B. Perfect Flush"></a>B. Perfect Flush</h1><div class="note link green"><p>Link: <a href="https://nanti.jisuanke.com/t/45345" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/45345</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>You are given a list of integers <script type="math/tex">x_{1}, x_{2}, \ldots, x_{n}</script> and a number <script type="math/tex">k</script>. It is guaranteed that each i from 1 to k appears in thelist at least once.Find the lexicographically smallest subsequence of x that contains each integer from 1 to k exactly once.</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>The first line will contain two integers <script type="math/tex">n</script> and <script type="math/tex">k</script>, with <script type="math/tex">1 \leq k \leq n \leq 200000</script>. The following n lines will each containan integer <script type="math/tex">x_{i}</script> with <script type="math/tex">1 \leq x_{i} \leq k</script>.</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>Write out on one line, separated by spaces, the lexicographically smallest subsequence of x that has each integer from 1 to k exactly once</p><p>样例输入1<br>6 3<br>3<br>2<br>1<br>3<br>1<br>3<br>样例输出1<br>2 1 3<br>样例输入2<br>10 5<br>5<br>4<br>3<br>2<br>1<br>4<br>1<br>1<br>5<br>5<br>样例输出2<br>3 2 1 4 5</p>              </div>            </details><h2 id="Probelm-solving"><a href="#Probelm-solving" class="headerlink" title="Probelm solving"></a>Probelm solving</h2><p>这道题的意思是给我们<script type="math/tex">n</script>个数，保证<script type="math/tex">1-n</script>每个数都至少出现一次，让我们找到一个字典序最小的子序列包含<script type="math/tex">1-n</script>的每个数且智能出现一次。<br>暴力肯定是不行的，这道题的题解做法是，首先统计每个数最后出现的一个位置。<br>然后遍历这个序列，我们称现在遍历到的这个序列的数为<script type="math/tex">x_i</script>，做一下操作</p><ol><li>如果<script type="math/tex">x_i</script>还未出现在答案序列，并且答案序列不为空，就比较<script type="math/tex">x_i</script>和答案序列中最后一个数的大小。如果大于序列中的最后一个数，直接放到答案序列就行，如果小于，就看后面还是否会出现当前答案序列的最后一个数，用当前的位置和答案序列中最后一个数出现的最后一个位置作比较即可。如果后面不会再出现了，也直接加到答案序列。</li><li>如果<script type="math/tex">x_i</script>已经出现在答案序列，跳过。</li></ol><p>最后输出即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 2e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int d[4][2]={1,0,0,1,-1,0,0,-1};int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    int n,k;    cin&gt;&gt;n&gt;&gt;k;    vector&lt;int&gt; a(n+1),ans,vis(n+1),pos(n+1);    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;a[i];        pos[a[i]]=i;    }    for(int i=1;i&lt;=n;i++){        if(vis[a[i]])   continue;        while(ans.size()&gt;0&amp;&amp;a[i]&lt;ans.back()&amp;&amp;i&lt;pos[ans.back()]){            vis[ans.back()]=0;            ans.pop_back();        }        ans.pb(a[i]);        vis[a[i]]=1;    }    for(auto i :ans){        if(i!=ans.back())            cout&lt;&lt;i&lt;&lt;&quot; &quot;;        else            cout&lt;&lt;i&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      昨天比赛中卡了好久的题，总觉得很熟悉但是想不起来做法。我还想着用数据结构做的时候，看到了题解上面很妙的做法。
    
    </summary>
    
      <category term="Training" scheme="/categories/Training/"/>
    
    
      <category term="vector" scheme="/tags/vector/"/>
    
      <category term="单调栈" scheme="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder ABC 166 题解</title>
    <link href="/2020/05/03/abc166/"/>
    <id>/2020/05/03/abc166/</id>
    <published>2020-05-03T14:34:04.000Z</published>
    <updated>2020-10-20T14:57:55.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A、-A-C"><a href="#A、-A-C" class="headerlink" title="A、    A?C"></a>A、    A?C</h2><p>直接判断输出即可。</p><h2 id="B、-Trick-or-Treat"><a href="#B、-Trick-or-Treat" class="headerlink" title="B、    Trick or Treat"></a>B、    Trick or Treat</h2><p>用一个数组统计出现过的，然后找没出现过的个数即可。</p><h2 id="C、-Peaks"><a href="#C、-Peaks" class="headerlink" title="C、    Peaks"></a>C、    Peaks</h2><p>存一下图，遍历即可。</p><h2 id="D、-I-hate-Factorization"><a href="#D、-I-hate-Factorization" class="headerlink" title="D、    I hate Factorization"></a>D、    I hate Factorization</h2><p>打表，-500-500的就够了    </p><h2 id="E、-This-Message-Will-Self-Destruct-in-5s"><a href="#E、-This-Message-Will-Self-Destruct-in-5s" class="headerlink" title="E、    This Message Will Self-Destruct in 5s"></a>E、    This Message Will Self-Destruct in 5s</h2><p>如果我们要找的两个数的下标位i,j。假设j&gt;i,可得<script type="math/tex">a_i+a_j=j-i</script><br>化简一下可得<script type="math/tex">a_i+i=j-a_j</script><br>所以我们统计每一个<script type="math/tex">j-a_j</script>出现的次数，遍历<script type="math/tex">a_i+i</script>累加即可。</p><h2 id="F、-Three-Variables-Game"><a href="#F、-Three-Variables-Game" class="headerlink" title="F、    Three Variables Game"></a>F、    Three Variables Game</h2><p>每次选小的加一，大的减一。如果相等的，看一下下一个操作来选择用哪个。</p>]]></content>
    
    <summary type="html">
    
      差亿点AK，虽然题目挺简单，但是还是记录一下吧。（我又飘了
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="思维" scheme="/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="atcoder" scheme="/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Eight HDU - 1043</title>
    <link href="/2020/05/03/hdu1043/"/>
    <id>/2020/05/03/hdu1043/</id>
    <published>2020-05-03T08:09:39.000Z</published>
    <updated>2020-10-20T14:57:55.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eight"><a href="#Eight" class="headerlink" title="Eight"></a>Eight</h1><div class="note link green"><p>Link: <a href="https://vjudge.net/problem/HDU-1043" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-1043</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>The 15-puzzle has been around for over 100 years; even if you don&#39;t know it by that name, you&#39;ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let&#39;s call the missing tile &#39;x&#39;; the object of the puzzle is to arrange the tiles so that they are ordered as:</p><p> 1  2  3  4<br> 5  6  7  8<br> 9 10 11 12<br>13 14 15  x</p><p>where the only legal operation is to exchange &#39;x&#39; with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle:</p><p> 1  2  3  4     1  2  3  4     1  2  3  4     1  2  3  4<br> 5  6  7  8     5  6  7  8     5  6  7  8     5  6  7  8<br> 9  x 10 12     9 10  x 12     9 10 11 12     9 10 11 12<br>13 14 11 15    13 14 11 15    13 14  x 15    13 14 15  x<br>            r-&gt;            d-&gt;            r-&gt;</p><p>The letters in the previous row indicate which neighbor of the &#39;x&#39; tile is swapped with the &#39;x&#39; tile at each step; legal values are &#39;r&#39;,&#39;l&#39;,&#39;u&#39; and &#39;d&#39;, for right, left, up, and down, respectively.</p><p>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing &#39;x&#39; tile, of course).</p><p>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus &#39;x&#39;. For example, this puzzle</p><p>1 2 3<br>x 4 6<br>7 5 8</p><p>is described by this list:</p><p>1 2 3 x 4 6 7 5 8</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>You will print to standard output either the word ``unsolvable&#39;&#39;, if the puzzle has no solution, or a string consisting entirely of the letters &#39;r&#39;, &#39;l&#39;, &#39;u&#39; and &#39;d&#39; that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases.<br>示例1<br>输入<br>2  3  4  1  5  x  7  6  8<br>输出<br>ullddrurdllurdruldr</p>              </div>            </details><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题有许多种解法。这里我用的是康拓展开。<br>康拓展开，将一个全排列跟一个整数对应起来。也就是哈希的思想。我们把这个3*3的图当成一个全排列看待即可。<br>因为最后我们要到达的状态是恒定的（12345678x），所以我们可以通过逆向bfs打一个表得到每种状态到达这个状态的路径。省了时间也省了空间。把x当成0看，就是0-8的全排列了。（其实没看题解之前想到了hash，但是不知道怎么来回转换，康拓展开nb</p><h2 id="康拓展开的模板"><a href="#康拓展开的模板" class="headerlink" title="康拓展开的模板"></a>康拓展开的模板</h2><pre><code class="lang-c++">int cantor(int *a){//获得hash值   int x=0;   for(int i=0;i&lt;9;i++){      int mi=0;      for(int j=i+1;j&lt;9;j++){         if(a[j]&lt;a[i])  mi++;      }      x+=FAC[9-i-1]*mi;   }   return x+1;}void decantor(int x,int *a){//通过hash值倒推回全排列   vector&lt;int&gt; v;   for(int i=0;i&lt;9;i++) v.pb(i);   for(int i=0;i&lt;9;i++){      int r=x%FAC[9-i-1];      int t=x/FAC[9-i-1];      x=r;      sort(v.begin(),v.end());      a[i]=v[t];      v.erase(v.begin()+t);   }}</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 4e5+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int miday[9],dt[4][2]= {1,0,-1,0,0,1,0,-1},result=46234,vis[maxn];string path[maxn];char op[5]=&quot;udlr&quot;;int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; struct node{   string path;   int val,pos;};node now,net;int cantor(int *a){   int x=0;   for(int i=0;i&lt;9;i++){      int mi=0;      for(int j=i+1;j&lt;9;j++){         if(a[j]&lt;a[i])  mi++;      }      x+=FAC[9-i-1]*mi;   }   return x+1;}void decantor(int x,int *a){   vector&lt;int&gt; v;   for(int i=0;i&lt;9;i++) v.pb(i);   for(int i=0;i&lt;9;i++){      int r=x%FAC[9-i-1];      int t=x/FAC[9-i-1];      x=r;      sort(v.begin(),v.end());      a[i]=v[t];      v.erase(v.begin()+t);   }}void bfs(){   queue&lt;node&gt; q;   for(int i=0;i&lt;8;i++) miday[i]=i+1;   miday[8]=0;   now.pos=8;now.val=result;now.path=&quot;&quot;;vis[result]=1;path[result]=&quot;&quot;;   q.push(now);   while(!q.empty()){      now=q.front();      q.pop();      for(int i=0;i&lt;4;i++){         int dx=(now.pos)/3+dt[i][0];         int dy=(now.pos)%3+dt[i][1];         if(dx&lt;0||dy&lt;0||dx&gt;2||dy&gt;2) continue;         net=now;net.pos=dx*3+dy;         decantor(now.val-1,miday);         swap(miday[now.pos],miday[net.pos]);         net.val=cantor(miday);         if(!vis[net.val]){            vis[net.val]=1;            net.path=op[i]+net.path;            q.push(net);            path[net.val]=net.path;         }      }   }   return ;}int main() {   ios::sync_with_stdio(0);   #ifdef Uncle_drew   freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);   freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);   #else   #endif   bfs();   char x;   while(cin&gt;&gt;x){      if(x==&#39;x&#39;){         now.pos=0;         miday[0]=0;      }else{         miday[0]=x-&#39;0&#39;;      }      for(int i=1;i&lt;9;i++){         cin&gt;&gt;x;         if(x==&#39;x&#39;){            now.pos=i;            miday[i]=0;         }else{            miday[i]=x-&#39;0&#39;;         }      }      now.val=cantor(miday);      if(!vis[now.val]){         cout&lt;&lt;&quot;unsolvable\n&quot;;      }else{         cout&lt;&lt;path[now.val]&lt;&lt;endl;      }   }   return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      逆向bfs+康拓展开+hash
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="HDU" scheme="/tags/HDU/"/>
    
      <category term="hash" scheme="/tags/hash/"/>
    
      <category term="bfs" scheme="/tags/bfs/"/>
    
      <category term="康拓展开" scheme="/tags/%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>JLOI2011-飞行路线</title>
    <link href="/2020/04/26/jloi2011/"/>
    <id>/2020/04/26/jloi2011/</id>
    <published>2020-04-26T08:50:54.000Z</published>
    <updated>2020-10-20T14:57:55.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JLOI2011-飞行路线"><a href="#JLOI2011-飞行路线" class="headerlink" title="[JLOI2011]飞行路线"></a>[JLOI2011]飞行路线</h1><div class="note link green"><p>Link: <a href="https://www.luogu.com.cn/problem/P4568" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4568</a></p></div><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在n个城市设有业务，设这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市，并且航线有一定的价格。<br>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。<br>第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。(0 ≤ s,t &lt; n)<br>接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。(0 ≤ a,b &lt; n,a与b不相等，0 ≤ c ≤ 1000)</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>只有一行，包含一个整数，为最少花费。<br>示例1<br>输入<br>5 6 1<br>0 4<br>0 1 5<br>1 2 5<br>2 3 5<br>3 4 5<br>2 3 3<br>0 2 100<br>输出<br>8</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">\begin{aligned}&\text { 对于 } 100 \% \text { 的数据, } 2 \leq n \leq 10^{4}, 1 \leq m \leq 5 \times 10^{4}, 0 \leq k \leq 10,0 \leq s, t, a, b \leq n, a \neq b, 0 \leq\\&c \leq 10^{3}\end{aligned}</script>              </div>            </details><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是给你一个图，你有<script type="math/tex">k</script>次机会可以让你走的路零代价，给你起点和终点，问你最短距离。<br>~一开始想着贪心着写，贪着贪着发现，我还是不够贪心~</p><p>后来才知道这就是一道模板题——分层图最短路。<br>网上讲解挺多的，大致意思就是有两种方法。一种是dp，一种是建图的时候直接建分层图。但是后者容易被卡空间。<br>不过在这里显然不用担心。</p><p>具体思路，就是，建图的时候，建<script type="math/tex">k</script>层。每层图根原图是一样的。但是在每一层之间，如果这两个点是联通的就加上一条权值为0的边。然后我们跑一边最短路。答案就是从起点到每一层的终点对应的点的最短路的最小值。<br>这思路挺妙的，如果你某次使某条路代价为零就等价于，从这几层图的中间选择了一条路。</p><p>还有就是这种分法很占空间。我开了<script type="math/tex">3*10^6+10</script>才过。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pb push_back#define mp make_pairconst int maxn = 3e6+10;const int mod = 1e9+7;const int INF = 0x3f3f3f3f;int n,m,k,s,t,head[maxn],cnt=1,dis[maxn];struct node{    int to,next,val;}p[maxn];void add(int u,int v,int w){    p[cnt].to=v;    p[cnt].next=head[u];    p[cnt].val=w;    head[u]=cnt++;}void solve(int s){    memset(dis,INF,sizeof(dis));    dis[s]=0;    priority_queue&lt;pair&lt;int,int&gt; &gt; q;    q.push(mp(0,s));    while(!q.empty()){        int u=q.top().second;q.pop();        for(int i=head[u];i;i=p[i].next){            int v=p[i].to;            if(dis[v]&gt;dis[u]+p[i].val){                dis[v]=dis[u]+p[i].val;                q.push(mp(-dis[v],v));            }        }    }}int main() {    ios::sync_with_stdio(0);    #ifdef Uncle_drew    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    #else    #endif    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;    for(int i=0,u,v,w;i&lt;m;i++){        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        for(int j=0;j&lt;=k;j++){            add(u+j*n,v+j*n,w);            add(v+j*n,u+j*n,w);            if(j&lt;k){                add(u+j*n,v+(j+1)*n,0);                add(v+j*n,u+(j+1)*n,0);            }        }    }//建图    solve(s);    int ans=INF;    for(int i=0;i&lt;=k;i++){        // cout&lt;&lt;dis[i*n+t]&lt;&lt;endl;        ans=min(ans,dis[i*n+t]);    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      分层最短路
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="Dijkstra" scheme="/tags/Dijkstra/"/>
    
      <category term="Priority queue" scheme="/tags/Priority-queue/"/>
    
      <category term="分层图最短路" scheme="/tags/%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="链式前向星" scheme="/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2009 最长距离</title>
    <link href="/2020/04/22/SCOI2009/"/>
    <id>/2020/04/22/SCOI2009/</id>
    <published>2020-04-22T01:03:11.000Z</published>
    <updated>2020-10-20T14:57:58.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SCOI2009-最长距离"><a href="#SCOI2009-最长距离" class="headerlink" title="[SCOI2009]最长距离"></a>[SCOI2009]最长距离</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><details green><summary> <p>点击查看题面</p> </summary>              <div class="content">              <p>windy有一块矩形土地，被分为 NM 块 11 的小格子。 有的格子含有障碍物。 如果从格子A可以走到格子B，那么两个格子的距离就为两个格子中心的欧几里德距离。 如果从格子A不可以走到格子B，就没有距离。 如果格子X和格子Y有公共边，并且X和Y均不含有障碍物，就可以从X走到Y。 如果windy可以移走T块障碍物，求所有格子间的最大距离。 保证移走T块障碍物以后，至少有一个格子不含有障碍物。</p><p>输入格式<br>第一行包含三个整数，N M T。 接下来有N行，每行一个长度为M的字符串，&#39;0&#39;表示空格子，&#39;1&#39;表示该格子含有障碍物。</p><p>输出格式<br>包含一个浮点数，保留6位小数。</p><p>输入输出样例<br>输入 #1<br>3 3 0<br>001<br>001<br>110<br>输出 #1<br>1.414214</p><p>输入 #2<br>4 3 0<br>001<br>001<br>011<br>000<br>输出 #2<br>3.605551</p><p>输入 #3<br>3 3 1<br>001<br>001<br>001<br>输出 #3<br>2.828427<br>说明/提示<br>20%的数据，满足 1 &lt;= N,M &lt;= 30 ； 0 &lt;= T &lt;= 0 。</p><p>40%的数据，满足 1 &lt;= N,M &lt;= 30 ； 0 &lt;= T &lt;= 2 。</p><p>100%的数据，满足 1 &lt;= N,M &lt;= 30 ； 0 &lt;= T &lt;= 30 。</p>              </div>            </details><h2 id="Problem-solving"><a href="#Problem-solving" class="headerlink" title="Problem solving"></a>Problem solving</h2><p>这道题的意思就是有一个<script type="math/tex">n*m</script>的图，某些点存在障碍，问你在移走最多<script type="math/tex">k</script>个障碍物之后，可以达到的最大的两点间距离，若两点有公共边且都没有障碍，两点可达。<br>我们可以发现，<span class="p red">问题的关键在于障碍物的处理</span>。因为我们只需要找两点之间的最大距离，所以这<script type="math/tex">k</script>个障碍物全都用来满足最大距离的情况就行了。<br>建图，把有障碍的地方距离建为<script type="math/tex">1</script>，其它可达的建为<script type="math/tex">0</script>。然后对于每个点，我们用<script type="math/tex">spfa</script>（或者<script type="math/tex">Dijkstra</script>）求出其他点到它的最短距离，如果最短距离小于等于<script type="math/tex">k</script>，说明我们可以通过移走障碍物把这两个点联通。然后更新一下最大值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 35;const int  INF = 0x3f3f3f3f;#define mp make_pair#define pii pair&lt;int,int&gt;string s[N];int n,m,k,dis[N][N],vis[N][N],d[4][2]={1,0,0,1,-1,0,0,-1};void spfa(int x,int y){    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;m;j++){            dis[i][j]=INF;            vis[i][j]=0;        }    }    queue&lt;pii&gt; q;    q.push(mp(x,y));    vis[x][y]=1;dis[x][y]=(s[x][y]==&#39;1&#39;);    while(!q.empty()){        pii mid=q.front();q.pop();        x=mid.first,y=mid.second;        vis[x][y]=0;        for(int i=0;i&lt;4;i++){            int dx=x+d[i][0],dy=y+d[i][1];            if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m)    continue;            if(dis[dx][dy]&gt;dis[x][y]+(s[dx][dy]==&#39;1&#39;)){                dis[dx][dy]=dis[x][y]+(s[dx][dy]==&#39;1&#39;);                q.push(mp(dx,dy));                vis[dx][dy]=1;            }        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;s[i];    double ans=0;    for(int a=0;a&lt;n;a++){        for(int b=0;b&lt;m;b++){            spfa(a,b);            for(int c=0;c&lt;n;c++){                for(int d=0;d&lt;m;d++){                    if(dis[c][d]&lt;=k){                        ans=max(ans,sqrt((a-c)*(a-c)+(b-d)*(b-d)));                    }                }            }        }    }    printf(&quot;%.6lf\n&quot;,ans);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      最短路好难啊~
    
    </summary>
    
      <category term="Algorithm" scheme="/categories/Algorithm/"/>
    
    
      <category term="Thinking" scheme="/tags/Thinking/"/>
    
      <category term="spfa" scheme="/tags/spfa/"/>
    
      <category term="scoi" scheme="/tags/scoi/"/>
    
  </entry>
  
</feed>
